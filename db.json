{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"source/images/format.png","path":"images/format.png","modified":0,"renderable":0},{"_id":"source/images/metadata.png","path":"images/metadata.png","modified":0,"renderable":0},{"_id":"source/images/schema.png","path":"images/schema.png","modified":0,"renderable":0},{"_id":"themes/anzhiyu/source/49890814.jpg","path":"49890814.jpg","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/512.png","path":"img/512.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/default_cover.jpg","path":"img/default_cover.jpg","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/comment_bg.png","path":"img/comment_bg.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/roadNetwork.png","path":"img/roadNetwork.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/friend/cc.png","path":"img/friend/cc.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/friend/czc.jpg","path":"img/friend/czc.jpg","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/friend/hx.jpg","path":"img/friend/hx.jpg","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/friend/ljj.png","path":"img/friend/ljj.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/friend/lyr.png","path":"img/friend/lyr.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/friend/lz.jpg","path":"img/friend/lz.jpg","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/friend/zmh.jpg","path":"img/friend/zmh.jpg","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/siteicon/16.png","path":"img/siteicon/16.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/siteicon/32.png","path":"img/siteicon/32.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/siteicon/apple-icon-180.png","path":"img/siteicon/apple-icon-180.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/siteicon/manifest-icon-192.maskable.png","path":"img/siteicon/manifest-icon-192.maskable.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/img/siteicon/manifest-icon-512.maskable.png","path":"img/siteicon/manifest-icon-512.maskable.png","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/js/anzhiyu/ai_abstract.js","path":"js/anzhiyu/ai_abstract.js","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/js/anzhiyu/comment_barrage.js","path":"js/anzhiyu/comment_barrage.js","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/js/anzhiyu/people.js","path":"js/anzhiyu/people.js","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/js/anzhiyu/random_friends_post.js","path":"js/anzhiyu/random_friends_post.js","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/js/anzhiyu/right_click_menu.js","path":"js/anzhiyu/right_click_menu.js","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/anzhiyu/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/images/cover_image/parquet.jpg","path":"images/cover_image/parquet.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_data/about.yml","hash":"f903b53856274efbcf17749e8808204b5f327716","modified":1731661077498},{"_id":"source/_data/creativity.yml","hash":"ab94ae08cb79b72f4738bd6b07add6be0154670c","modified":1731411639401},{"_id":"source/_posts/使用Python提取城市路网.md","hash":"347f08b099aef0a1b38b26b0b2c4d10062d598f3","modified":1732197588215},{"_id":"source/_data/link.yml","hash":"1abea4dc1c6b765957f33883b886e39e9cbaa488","modified":1731484614164},{"_id":"source/_posts/Parquet.md","hash":"77c17c4c66a6fed87e80ca0ddcfbed1284d874fb","modified":1732197590571},{"_id":"source/about/index.md","hash":"1d2e1ba862f25b995d989eb27902839ae0dc9c2a","modified":1731492939378},{"_id":"source/categories/index.md","hash":"0815e7d4a3171a3eacb6279fcd6e2f8d352b37b8","modified":1731403140894},{"_id":"source/images/format.png","hash":"a71da3ce97ed80edb5a75712c2f057953e3b44e3","modified":1732193878718},{"_id":"source/images/schema.png","hash":"773d46dc6e9b1895b16a2724f336913458a2d232","modified":1732189626875},{"_id":"source/link/index.md","hash":"0eec7e360c46703774a98025df30032bed3ac3e8","modified":1731481831420},{"_id":"source/tags/index.md","hash":"ebca351f6a17e26b0670f061e3ed4a5843c67471","modified":1731413208493},{"_id":"source/images/cover_image/parquet.png","hash":"94138cbd8604ccdf5b7635df170ac4fba275bc88","modified":1732195510058},{"_id":"source/images/metadata.png","hash":"cb74b8b1ff9272d06cb718f720344b22b2b8129c","modified":1732193935071},{"_id":"themes/anzhiyu/source/css/_extra/home_top/random-banner.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1731409466277},{"_id":"themes/anzhiyu/.gitignore","hash":"17b9594db1006e57f76e109924db33e54f0f2d87","modified":1731409466196},{"_id":"themes/anzhiyu/LICENSE","hash":"1eba7caf09a39110ad2f542e3ed8700d1a69c6d3","modified":1731409466197},{"_id":"themes/anzhiyu/README_EN.md","hash":"23597148859005cb89e9b6a0be708bf95ae557fb","modified":1731409466197},{"_id":"themes/anzhiyu/README.md","hash":"2342370ab20c202c24ee530d80749f158d416fc3","modified":1731409466197},{"_id":"themes/anzhiyu/_config.yml","hash":"f37684d60a5159e264ff803b61185653748fc22d","modified":1731409466198},{"_id":"themes/anzhiyu/plugins.yml","hash":"1b66b55771dbac1866909fa306358d11b255821e","modified":1731409466246},{"_id":"themes/anzhiyu/sw-rules.js","hash":"91eb0c94682ce1bffdbbd07a5bb7e5c6e00aa8c6","modified":1731409466331},{"_id":"themes/anzhiyu/package.json","hash":"a7f83155236c1dd6a309171efaa0680e78afd748","modified":1731409466245},{"_id":"themes/anzhiyu/languages/en.yml","hash":"824f3a5bfe0f5848cc4a919c183bae214e660242","modified":1731409466199},{"_id":"themes/anzhiyu/languages/zh-CN.yml","hash":"5f6fad5076023da2d1fae9f5277e081168b0c1eb","modified":1731409466199},{"_id":"themes/anzhiyu/layout/archive.pug","hash":"6a61277de07cf2724c865f251cb6f2385a6664ae","modified":1731409466200},{"_id":"themes/anzhiyu/languages/zh-TW.yml","hash":"00d538fc38c1a88fd126c2e57c29dd860e9bc2bd","modified":1731409466199},{"_id":"themes/anzhiyu/layout/index.pug","hash":"818aeebcd24466aade30e632ee5275f92e73baea","modified":1731409466244},{"_id":"themes/anzhiyu/layout/category.pug","hash":"a54b00a06469b5cf84993a370194c08d88e68802","modified":1731484914672},{"_id":"themes/anzhiyu/layout/page.pug","hash":"57db7a52cbf647256b0346e6c0cd1539732a77e8","modified":1731409466244},{"_id":"themes/anzhiyu/layout/post.pug","hash":"666241d431679ea7f9c94ce345bac8405f6bc5e7","modified":1731409466244},{"_id":"themes/anzhiyu/layout/tag.pug","hash":"fe81f8e8193dae2db7693e5464d4746704bbecdf","modified":1731409466245},{"_id":"themes/anzhiyu/languages/default.yml","hash":"8f22a9946744a2a4682564cf2c7e5f8dde6f1c25","modified":1731409466199},{"_id":"themes/anzhiyu/source/49890814.jpg","hash":"ecdf539191760a2e1210a843c8b43b5342d6b947","modified":1731399348294},{"_id":"themes/anzhiyu/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"1c50c14dd6b66ab636a8852e9b967c40671f1200","modified":1731409466191},{"_id":"themes/anzhiyu/source/favicon.ico","hash":"14310db268ea8d3b2096f434c6e293fc207f5f09","modified":1731409466309},{"_id":"themes/anzhiyu/.github/ISSUE_TEMPLATE/config.yml","hash":"9d8e5494501458ed1cfeb2eb9e9a57b124dc5010","modified":1731409466192},{"_id":"themes/anzhiyu/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"0aaafd614172a6ca77a9b41fd3e81e885e8cfec7","modified":1731409466192},{"_id":"themes/anzhiyu/.github/workflows/issue_close_question.yml","hash":"a83655836dee52bcec1470bc394aa7dbc2cb487e","modified":1731409466192},{"_id":"themes/anzhiyu/.github/workflows/issue_duplicate.yml","hash":"9ce2c4845fd229e7a01d9f61da1c9b1fa0c030ec","modified":1731409466193},{"_id":"themes/anzhiyu/.github/workflows/issue_close_stale.yml","hash":"b7b75a00b86da3b9361d37e5e17926e66e376d13","modified":1731409466193},{"_id":"themes/anzhiyu/.github/workflows/issue_invalid.yml","hash":"a4f2e5af1651d4683e2988137c7b366f5dc37bdf","modified":1731409466193},{"_id":"themes/anzhiyu/.github/workflows/issue_question.yml","hash":"7a10849dedf026ddcab8b0d3c8205ad6fe5b8327","modified":1731409466194},{"_id":"themes/anzhiyu/.github/workflows/issue_wontfix.yml","hash":"288b1971d78e4e6d284e96d924c87c264737830d","modified":1731409466195},{"_id":"themes/anzhiyu/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1731409466196},{"_id":"themes/anzhiyu/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1731409466196},{"_id":"themes/anzhiyu/layout/includes/404.pug","hash":"799817011e194e6b1fc9ccb5530f5d96d59cfcc0","modified":1731409466201},{"_id":"themes/anzhiyu/layout/includes/bbTimeList.pug","hash":"e5e64f90df68d2679dd6593b02fb6c64c8ce8620","modified":1731409466205},{"_id":"themes/anzhiyu/layout/includes/additional-js.pug","hash":"5940f3f42d441667ac3ad2ff76b7b9ba79343e9a","modified":1731409466201},{"_id":"themes/anzhiyu/layout/includes/categoryGroup.pug","hash":"e08a308acca100cec2ccc086b9c2cff047582fda","modified":1731409466206},{"_id":"themes/anzhiyu/layout/includes/footer.pug","hash":"bcc45f9b91ddaa561fc3239e834381238964aad7","modified":1731409466207},{"_id":"themes/anzhiyu/layout/includes/head.pug","hash":"c1c11b576897466aa5009dc32e884ee9b55162e3","modified":1731409466207},{"_id":"themes/anzhiyu/layout/includes/mourn.pug","hash":"fec8325d90968ccf376fc87b81671e26ba8fc702","modified":1731409466214},{"_id":"themes/anzhiyu/layout/includes/layout.pug","hash":"9b19516e186b6145441e38ed575eab6c065da001","modified":1731409466212},{"_id":"themes/anzhiyu/layout/includes/music.pug","hash":"f45cee9da98d854f78f7fdd8f14c4be427a09d51","modified":1731409466214},{"_id":"themes/anzhiyu/layout/includes/pagination.pug","hash":"7884c6ef7b71dd3f4ebb5a3de2c062d7668b96a5","modified":1731409466220},{"_id":"themes/anzhiyu/layout/includes/shortcutKey.pug","hash":"738d2932e68a782be2a80a6af2db1014c272cfe7","modified":1731409466221},{"_id":"themes/anzhiyu/layout/includes/sidebar.pug","hash":"fc56ee028770e230d4705ab74cba054c174ae500","modified":1731409466222},{"_id":"themes/anzhiyu/layout/includes/rightside.pug","hash":"5462d757964e470d1d7abe0a7ba3d6a9566e0e00","modified":1731409466221},{"_id":"themes/anzhiyu/scripts/events/404.js","hash":"16484d781b273f20c4fbddf27ca283e03d7c0910","modified":1731409466246},{"_id":"themes/anzhiyu/scripts/events/cdn.js","hash":"fec4fbd14b29611684cc5a9ec1ba7a5b8a5cc996","modified":1731409466247},{"_id":"themes/anzhiyu/scripts/events/comment.js","hash":"176332aa4d01728d0bd084e9b02c60167dc307dd","modified":1731409466247},{"_id":"themes/anzhiyu/scripts/events/init.js","hash":"404b1200a3be17dbc14ccbb293aa17389d3a834b","modified":1731409466247},{"_id":"themes/anzhiyu/scripts/events/merge_config.js","hash":"38de538f3398c1be907c91f611344f4cc1009555","modified":1731409466248},{"_id":"themes/anzhiyu/scripts/events/stylus.js","hash":"c4de22ef3e1e84a96f9e48d450b3dbaeb5b85ecf","modified":1731409466248},{"_id":"themes/anzhiyu/scripts/events/welcome.js","hash":"6c3f69381c11fdb651684bcc04c077bcff892a2f","modified":1731409466249},{"_id":"themes/anzhiyu/scripts/filters/post_lazyload.js","hash":"19f85dc094e3d2b72244cc0ef59e60f88373b779","modified":1731409466249},{"_id":"themes/anzhiyu/scripts/filters/random_cover.js","hash":"17497ecec828b68005762d627c54dde42de0806f","modified":1731409466250},{"_id":"themes/anzhiyu/scripts/helpers/aside_archives.js","hash":"12be80b9828008e9dd6aa7f57e875acda88e7046","modified":1731409466250},{"_id":"themes/anzhiyu/scripts/helpers/aside_categories.js","hash":"6e97bc9b99fac73561793bc746e9199636f1cf78","modified":1731409466250},{"_id":"themes/anzhiyu/scripts/helpers/catalog_list.js","hash":"45d9261f55d3176bc5ec5b26217c01066a0d98e5","modified":1731484914673},{"_id":"themes/anzhiyu/scripts/helpers/findArchiveLength.js","hash":"612acfe4fd0d1d86676496dbb8e3e78dba030605","modified":1731409466251},{"_id":"themes/anzhiyu/scripts/helpers/inject_head_js.js","hash":"52f710f99904521c37fc1f19a33929799ceeafe2","modified":1731409466252},{"_id":"themes/anzhiyu/scripts/helpers/get_version.js","hash":"799ae97c1368c395649444b9e5a71f9074852522","modified":1731409466251},{"_id":"themes/anzhiyu/scripts/helpers/page.js","hash":"b0a3c347ae90ac998fa17e9e67b7cd290d4d7ab7","modified":1731409466253},{"_id":"themes/anzhiyu/scripts/helpers/random.js","hash":"feeabd29864fe8a2e50edc4d6c7523897f38aaca","modified":1731409466253},{"_id":"themes/anzhiyu/scripts/helpers/related_post.js","hash":"b6960063129984f1c6760e21c8215a4739fdbac5","modified":1731409466253},{"_id":"themes/anzhiyu/scripts/helpers/sort_attr_post.js","hash":"1cf55b611e4342f5a0c0e26bf69cf2a401cdcfff","modified":1731409466254},{"_id":"themes/anzhiyu/scripts/helpers/tags_page_list.js","hash":"501f0060ff9e8733c77996376f02211667f30738","modified":1731484914673},{"_id":"themes/anzhiyu/scripts/helpers/year.js","hash":"94f15ddba7d29cdcc4dd52ed6c35c9c29cc19d37","modified":1731409466254},{"_id":"themes/anzhiyu/source/css/index.styl","hash":"10e57f33d5326128dd736135d15c8d46162d27de","modified":1731409466308},{"_id":"themes/anzhiyu/source/img/512.png","hash":"6988b23a31304d9de45b95a1e7c05dd42024e560","modified":1731409466310},{"_id":"themes/anzhiyu/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1731409466310},{"_id":"themes/anzhiyu/source/img/default_cover.jpg","hash":"455fa65e2736f61ac36360dd4f76fc1ab6a1cdd5","modified":1731409466311},{"_id":"themes/anzhiyu/source/css/var.styl","hash":"94afa286f44875f20b7bc1b983069bee0b97058c","modified":1731409466309},{"_id":"themes/anzhiyu/source/img/favicon.ico","hash":"14310db268ea8d3b2096f434c6e293fc207f5f09","modified":1731409466311},{"_id":"themes/anzhiyu/source/img/comment_bg.png","hash":"91612a887446fb436e9151981e2289f2a426a3e5","modified":1731409466311},{"_id":"themes/anzhiyu/scripts/tag/Introduction-card.js","hash":"15d1a82549af21ef55dd40758c16ddf26a17fe22","modified":1731409466254},{"_id":"themes/anzhiyu/scripts/tag/bilibili.js","hash":"cc3f9f29f777dea0e4714ce08be4edb301c0b768","modified":1731409466255},{"_id":"themes/anzhiyu/scripts/tag/btns.js","hash":"84992525efbccb9e87bbc72dfef2968212cabf2e","modified":1731409466256},{"_id":"themes/anzhiyu/scripts/tag/button.js","hash":"8f6d382ea394bef44da90cdf197dd2e207d5c7db","modified":1731409466256},{"_id":"themes/anzhiyu/scripts/tag/checkbox.js","hash":"636cef0f4500a14b123c6b21187fb67989472cbd","modified":1731409466256},{"_id":"themes/anzhiyu/scripts/tag/flink.js","hash":"f987ce74edeee13a83fe526c234626eeae0588f0","modified":1731409466257},{"_id":"themes/anzhiyu/scripts/tag/dogeplayer.js","hash":"facf3251b8eb2fd26f2d78906934d463d0adbd0f","modified":1731409466256},{"_id":"themes/anzhiyu/scripts/tag/folding.js","hash":"93f56903a307b4ce54963b40050fbb9aeb5baf47","modified":1731409466258},{"_id":"themes/anzhiyu/scripts/tag/gallery.js","hash":"3fb27bd4b176b15f2e3a54d452ae4ef922c763d3","modified":1731409466258},{"_id":"themes/anzhiyu/scripts/tag/hide.js","hash":"8c9275fd1a357670a84577306b5e9568ab875a7b","modified":1731409466258},{"_id":"themes/anzhiyu/scripts/tag/iconfont.js","hash":"ea983f7c8dd060ed411044df1c10aa6b72dec34f","modified":1731409466259},{"_id":"themes/anzhiyu/scripts/tag/image.js","hash":"382cae620f3917cc99762942ad40b3ff146216ba","modified":1731409466259},{"_id":"themes/anzhiyu/scripts/tag/label.js","hash":"160cce6b5d58187dea0cb907116cda2bbfe6ee1c","modified":1731409466260},{"_id":"themes/anzhiyu/scripts/tag/inline-labels.js","hash":"eaaedc3d65384e0beb4306534ef4ed202b46da18","modified":1731409466259},{"_id":"themes/anzhiyu/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1731409466259},{"_id":"themes/anzhiyu/scripts/tag/link.js","hash":"9b7f81107a7c9d887060f6d3309f444090d7ccc3","modified":1731409466260},{"_id":"themes/anzhiyu/scripts/tag/media.js","hash":"ebe4a6ebe34e8d77c0652c63bd5f763439743eb2","modified":1731409466260},{"_id":"themes/anzhiyu/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1731409466261},{"_id":"themes/anzhiyu/scripts/tag/mermaid.js","hash":"e1a5e8e412cbbb3fc361136e9a5408170b7d93f8","modified":1731409466260},{"_id":"themes/anzhiyu/scripts/tag/site.js","hash":"b085ab9682b8465b1399c60889283d809a91e980","modified":1731409466261},{"_id":"themes/anzhiyu/scripts/tag/span.js","hash":"89aaa0678188aa85ec18116af4b036f80ca7c073","modified":1731409466261},{"_id":"themes/anzhiyu/scripts/tag/tabs.js","hash":"5dac02bb83aab3ff2afb3317ef7a2a626440671f","modified":1731409466261},{"_id":"themes/anzhiyu/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1731409466262},{"_id":"themes/anzhiyu/scripts/tag/tip.js","hash":"0c2833f461168fa04c23bfd87f1274976d611fc1","modified":1731409466262},{"_id":"themes/anzhiyu/source/js/main.js","hash":"426ef036cb913ebb2aabe24bac1681757464b47c","modified":1731409466329},{"_id":"themes/anzhiyu/source/js/tw_cn.js","hash":"b3dfb877a3f2e66086b9e4f714f906df6f104700","modified":1731409466330},{"_id":"themes/anzhiyu/source/js/utils.js","hash":"8072d375ba873eb6d7d649f39689b4b03c33cb1d","modified":1731409466331},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/ai-info.pug","hash":"73ca24d63adbab59ef206771107a90f3afb61d56","modified":1731409466201},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/clock.pug","hash":"475ef93ee833f283e02a0a0e4e5a0ab8743e7e19","modified":1731409466202},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/console.pug","hash":"e05a5f1debeb6a48e918e04097f0a4551c93a405","modified":1731409466202},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/log-js.pug","hash":"b298ec00407d7e30b744a56ee8df8cec39989e52","modified":1731409466202},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/rightmenu.pug","hash":"60a6829fed3cfebf7bdab3475a4c0291a82a678c","modified":1731409466203},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/tags-group-all.pug","hash":"b3fd7a18a9b87500348eb36be62ca29e91b58dd8","modified":1731409466205},{"_id":"themes/anzhiyu/layout/includes/bili-banner/index.pug","hash":"e3954ae43a708a560894fb28a21ac369a5b2d422","modified":1731409466206},{"_id":"themes/anzhiyu/layout/includes/head/analytics.pug","hash":"c1e45d4d0bd905ddcd2282de4fe89be92e67847d","modified":1731409466208},{"_id":"themes/anzhiyu/layout/includes/head/Open_Graph.pug","hash":"2f0a172bd29333a2c6301ba4b86a74173f5502d3","modified":1731409466208},{"_id":"themes/anzhiyu/layout/includes/head/config_site.pug","hash":"c50d21cd3ee0d45d8fe65ed679c4d131ef4ed7e6","modified":1731409466208},{"_id":"themes/anzhiyu/layout/includes/head/config.pug","hash":"41f77ddd5c3259d7f74f831b40dfa6ab202a990a","modified":1731409466208},{"_id":"themes/anzhiyu/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1731409466209},{"_id":"themes/anzhiyu/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1731409466209},{"_id":"themes/anzhiyu/layout/includes/head/preconnect.pug","hash":"01cf3be31783c0432ee2c79a8dc4c1422832cbe0","modified":1731409466210},{"_id":"themes/anzhiyu/layout/includes/head/pwa.pug","hash":"0fc38262a891a66f98972fe0389ad9a5e1abdb7d","modified":1731409466210},{"_id":"themes/anzhiyu/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1731409466210},{"_id":"themes/anzhiyu/layout/includes/header/menu_item.pug","hash":"c3f390d17d92da630892f275dc935f04a7a18dbf","modified":1731409466211},{"_id":"themes/anzhiyu/layout/includes/header/index.pug","hash":"b4a9f655175fca7cfe9ef3ba3866d763271fa081","modified":1731409466211},{"_id":"themes/anzhiyu/layout/includes/header/post-info.pug","hash":"0c43738c963d97cc3e28c95004d0d689fb395217","modified":1731409466211},{"_id":"themes/anzhiyu/layout/includes/header/nav.pug","hash":"846131493ff841e15ff7dd145033331851b5af18","modified":1731409466211},{"_id":"themes/anzhiyu/layout/includes/header/social.pug","hash":"7e9ee70012fdef99e80aa92fb301e27900a8ec6b","modified":1731409466212},{"_id":"themes/anzhiyu/layout/includes/loading/fullpage-loading.pug","hash":"1ffb745ce3a56f5ab180cdf08907d3e3ea20d387","modified":1731409466212},{"_id":"themes/anzhiyu/layout/includes/loading/index.pug","hash":"81362a8c82029119d02b33f0f7bed249950040f0","modified":1731409466213},{"_id":"themes/anzhiyu/layout/includes/loading/pace.pug","hash":"8f25b42cb6c2c07ea609ad69c243bb11463d8b60","modified":1731409466213},{"_id":"themes/anzhiyu/layout/includes/mixins/article-sort.pug","hash":"7527afa245ae66e8913d72627e9bea7bdc38ad50","modified":1731409466213},{"_id":"themes/anzhiyu/layout/includes/mixins/post-ui.pug","hash":"4b9b6377d14e3bdf977ed130324c8d043945f057","modified":1731409466214},{"_id":"themes/anzhiyu/layout/includes/page/about.pug","hash":"b2c1823828e8d602066886acc00adf997ddbe81c","modified":1731658673546},{"_id":"themes/anzhiyu/layout/includes/page/album.pug","hash":"6473c0f664bc1d7b02ecbb1321a895d506dc5094","modified":1731409466215},{"_id":"themes/anzhiyu/layout/includes/page/album_detail.pug","hash":"b056b5cc18876665316e235b60247cdc589c8f99","modified":1731409466216},{"_id":"themes/anzhiyu/layout/includes/page/categories.pug","hash":"2a9ad7e38cda70a54e7a65a513f0748fdee3ca9e","modified":1731409466216},{"_id":"themes/anzhiyu/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1731409466216},{"_id":"themes/anzhiyu/layout/includes/page/equipment.pug","hash":"7bd7f12123eb8d6b5ea65397642fec92cdbcdb1e","modified":1731409466216},{"_id":"themes/anzhiyu/layout/includes/page/essay.pug","hash":"0e317d13c40e8393962cf5fa39fee6cf82601007","modified":1731409466218},{"_id":"themes/anzhiyu/layout/includes/page/fcircle.pug","hash":"42998c6f90aa1e5ec87ba628e42b2a16889970e1","modified":1731409466218},{"_id":"themes/anzhiyu/layout/includes/page/flink.pug","hash":"7cf8f32581202e60fdc960f2f73ef9bcec5ff27f","modified":1731409466219},{"_id":"themes/anzhiyu/layout/includes/page/music.pug","hash":"2cee254ce63d5890e6cabb358b29e0c01275abc3","modified":1731409466219},{"_id":"themes/anzhiyu/layout/includes/page/room.pug","hash":"c509876ab0488cdc3a21f0dcbea01abdcae58a31","modified":1731409466219},{"_id":"themes/anzhiyu/layout/includes/page/tags.pug","hash":"affa27b6fa972c2868dc7a445342becea43476b9","modified":1731409466219},{"_id":"themes/anzhiyu/layout/includes/popup/index.pug","hash":"d7144d918882727b60af84269761e6e4ce1987ad","modified":1731409466220},{"_id":"themes/anzhiyu/layout/includes/post/post-copyright.pug","hash":"c0849c39a27d1e2952dc59df1f0200856e21068a","modified":1731409466220},{"_id":"themes/anzhiyu/layout/includes/post/ptool.pug","hash":"90ad5d7c0ab8da38d71b514c6d4e14488f5c66c8","modified":1731409466221},{"_id":"themes/anzhiyu/layout/includes/post/reward.pug","hash":"22af38003ab111e6449c029310a32021bb2a00a3","modified":1731409466221},{"_id":"themes/anzhiyu/layout/includes/top/top.pug","hash":"2b68f90a9f14f29828602289da867226b2e3c144","modified":1731409466238},{"_id":"themes/anzhiyu/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1731409466238},{"_id":"themes/anzhiyu/layout/includes/widget/card_announcement.pug","hash":"ac60c45ae916120aab1e5c5039444029042eb3a4","modified":1731409466238},{"_id":"themes/anzhiyu/layout/includes/widget/card_archives.pug","hash":"aea77a8644328f08b79f18d3b43702b0d8eb853c","modified":1731409466239},{"_id":"themes/anzhiyu/layout/includes/widget/card_author.pug","hash":"fd12d544418d11495878dedd6dc0155078cc48bb","modified":1731409466239},{"_id":"themes/anzhiyu/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1731409466239},{"_id":"themes/anzhiyu/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1731409466241},{"_id":"themes/anzhiyu/layout/includes/widget/card_console_archives.pug","hash":"cd4626a66fe724241d8a219e78308136b4919c6f","modified":1731409466241},{"_id":"themes/anzhiyu/layout/includes/widget/card_console_tags.pug","hash":"2d9385004542fe1ce615a9b4f33e45e98eb7befc","modified":1731409466242},{"_id":"themes/anzhiyu/layout/includes/widget/card_newest_comment.pug","hash":"f136d6265e7a4e77772853c248a26804d35697dd","modified":1731409466242},{"_id":"themes/anzhiyu/layout/includes/widget/card_tags.pug","hash":"b8315b369164ee12c79cd0d1ebc11753e3c26f4d","modified":1731409466243},{"_id":"themes/anzhiyu/layout/includes/widget/card_post_toc.pug","hash":"9c849ba0451a314a1d97016be7b12f04c3ce6444","modified":1731409466242},{"_id":"themes/anzhiyu/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1731409466243},{"_id":"themes/anzhiyu/layout/includes/widget/card_recent_post.pug","hash":"1740e6ef4e483c108dd6af5808ed7e99c644a4d0","modified":1731409466242},{"_id":"themes/anzhiyu/layout/includes/widget/card_webinfo.pug","hash":"7d3cae5dac3e0b2993798839df3d3cfac1fd97e9","modified":1731409466243},{"_id":"themes/anzhiyu/layout/includes/widget/card_weixin.pug","hash":"7725687c5db4329d989350f2d3e1de72b6e69156","modified":1731409466243},{"_id":"themes/anzhiyu/layout/includes/widget/index.pug","hash":"4b20439472a1cefd958afc6c882617c6fad6a0cd","modified":1731409466244},{"_id":"themes/anzhiyu/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1731409466222},{"_id":"themes/anzhiyu/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1731409466230},{"_id":"themes/anzhiyu/layout/includes/third-party/footerBarSubtitle.pug","hash":"62cefd8319c3819e2d0606a047cb90583c28cb78","modified":1731409466230},{"_id":"themes/anzhiyu/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1731409466233},{"_id":"themes/anzhiyu/layout/includes/third-party/pjax.pug","hash":"e0f26227c21544960b9abeb9ef7e9e5a02fffc64","modified":1731409466234},{"_id":"themes/anzhiyu/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1731409466234},{"_id":"themes/anzhiyu/layout/includes/third-party/subtitle.pug","hash":"d561d36229692e2c8a9ee45a7c24c0c2b3599170","modified":1731409466237},{"_id":"themes/anzhiyu/source/css/_layout/404.styl","hash":"6c984a3a6ac4599ea11f56f218ab575242a6217e","modified":1731409466288},{"_id":"themes/anzhiyu/source/css/_layout/banner.styl","hash":"31df78e8a76590d735d27c82196b9ce0ba6e722f","modified":1731409466289},{"_id":"themes/anzhiyu/source/css/_layout/aside.styl","hash":"fadd9e7e75b4b2c269310928859d5ec734aaf056","modified":1731409466288},{"_id":"themes/anzhiyu/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1731409466289},{"_id":"themes/anzhiyu/source/css/_layout/comments.styl","hash":"74a11d371c2e3a7f02ab314f769483960399b2b0","modified":1731409466289},{"_id":"themes/anzhiyu/source/css/_layout/footer.styl","hash":"fe3004296f8eff61155b7095f78bfa7bc2331d08","modified":1731409466289},{"_id":"themes/anzhiyu/source/css/_layout/head.styl","hash":"f093d83d13d778cd0e0053e1b4dde63d66d4bce2","modified":1731409466290},{"_id":"themes/anzhiyu/source/css/_layout/home_top.styl","hash":"1df055ba6519f6920029cc4400fc39d89602440f","modified":1731409466290},{"_id":"themes/anzhiyu/source/css/_layout/nav.styl","hash":"978915633e99e1d49bd06b94bea2eb405c8fcba0","modified":1731409466291},{"_id":"themes/anzhiyu/source/css/_layout/oneGraphFlow.styl","hash":"3a2a8549df55fb053871576be20e7e85fe4cda37","modified":1731409466291},{"_id":"themes/anzhiyu/source/css/_layout/pagination.styl","hash":"e12ff8f89458b17659e58dc65fdd2b9e7d7b4c68","modified":1731409466291},{"_id":"themes/anzhiyu/source/css/_layout/post.styl","hash":"ec6a5d69475f528dfd08a7cc0877d904a4b4bcbf","modified":1731409466292},{"_id":"themes/anzhiyu/source/css/_layout/ptool.styl","hash":"d9ca5e1a7b584c96246fb626aa74f85766c481aa","modified":1731409466292},{"_id":"themes/anzhiyu/source/css/_layout/relatedposts.styl","hash":"96825d6fec11a7caca5d7be6ce67b985a5be8bb2","modified":1731409466292},{"_id":"themes/anzhiyu/source/css/_layout/reward.styl","hash":"a1db997b40d35bcbb270937d76bf54021bccdda2","modified":1731409466292},{"_id":"themes/anzhiyu/source/css/_layout/rightside.styl","hash":"5d92b9bb99515d391323ddcaa91bfcdc5be41f44","modified":1731409466293},{"_id":"themes/anzhiyu/source/css/_layout/rightmenu.styl","hash":"67ed9f69ce7e88af1d96667e112f5592d1435730","modified":1731409466293},{"_id":"themes/anzhiyu/source/css/_layout/shortcutKey.styl","hash":"9f45ebfba4fd0c6bde7877b06d7e1b3b1e7da405","modified":1731409466293},{"_id":"themes/anzhiyu/source/css/_layout/sidebar.styl","hash":"1414615f345f00cc85bfc81d33268a95a2cb1090","modified":1731409466294},{"_id":"themes/anzhiyu/source/css/_layout/third-party.styl","hash":"b5f366f4c5286ca4321c832852feddda1f18c960","modified":1731409466294},{"_id":"themes/anzhiyu/source/css/_global/function.styl","hash":"67ae8fa268d4dfe7ac691adbb1b0fdf7d2afab8f","modified":1731409466282},{"_id":"themes/anzhiyu/source/css/_global/index.styl","hash":"2c2a0bb1ec71246eaccc80e944ea75ed61c4d1b6","modified":1731409466285},{"_id":"themes/anzhiyu/source/css/_global/icon.styl","hash":"0a8e0470910209033479ef515013bb968db9e4b5","modified":1731409466282},{"_id":"themes/anzhiyu/source/css/_global/loading.styl","hash":"0dea01a2d462685b952fa41f51de784149b45e4f","modified":1731409466285},{"_id":"themes/anzhiyu/source/css/_highlight/theme.styl","hash":"fd8115debce97b92c31927abb877de1bdf55fa83","modified":1731409466288},{"_id":"themes/anzhiyu/source/css/_highlight/highlight.styl","hash":"67c3f00d450ee4f992c2561cd4fd9e6b3bba2099","modified":1731409466285},{"_id":"themes/anzhiyu/source/css/_mode/darkmode.styl","hash":"c0e081e0fac44041942c1dcb2f799095c4116e20","modified":1731409466294},{"_id":"themes/anzhiyu/source/css/_mode/readmode.styl","hash":"618694850dfa8fac81e21ea369fb8f5589ac0d0f","modified":1731409466295},{"_id":"themes/anzhiyu/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1731409466295},{"_id":"themes/anzhiyu/source/css/_page/about.styl","hash":"08e81e2fa5b5e761211115c733e657f56fbdc507","modified":1731409466295},{"_id":"themes/anzhiyu/source/css/_page/archives.styl","hash":"f70bfb4e5b5b59c5713695927c2140957dc7aa1f","modified":1731409466296},{"_id":"themes/anzhiyu/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1731409466296},{"_id":"themes/anzhiyu/source/css/_page/common.styl","hash":"2ad261e7a747e2e43757f4c11324c9ed459fdbc5","modified":1731409466296},{"_id":"themes/anzhiyu/source/css/_page/equipment.styl","hash":"5a4cbddb41aee76cb2a9c5433b7b5a487f118da7","modified":1731409466296},{"_id":"themes/anzhiyu/source/css/_page/flink.styl","hash":"342b32142741c6a51f5219c93b9e3fad95430145","modified":1731409466298},{"_id":"themes/anzhiyu/source/css/_page/homepage.styl","hash":"8310390419d1eb5b23ae48aced4a87b0318e85be","modified":1731409466298},{"_id":"themes/anzhiyu/source/css/_page/music.styl","hash":"cfeba567ccb6bc421261d71a2e50242a955ba099","modified":1731409466299},{"_id":"themes/anzhiyu/source/css/_page/reward.styl","hash":"bbe91f4f0525a01901be2794f698ed99f5cb58bd","modified":1731409466299},{"_id":"themes/anzhiyu/source/css/_page/tag_page.styl","hash":"7a93cd4509a16b845ce2a9044320f43214dbcdc5","modified":1731409466299},{"_id":"themes/anzhiyu/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1731409466299},{"_id":"themes/anzhiyu/source/css/_search/algolia.styl","hash":"e1dda3de7bbfce226bb8300db15a930176289a27","modified":1731409466300},{"_id":"themes/anzhiyu/source/css/_search/index.styl","hash":"c315988ee28ad853aaa2060055d10aa88225a131","modified":1731409466300},{"_id":"themes/anzhiyu/source/css/_search/local-search.styl","hash":"45792c13c7c439d412b7dc597d74d24f3b598406","modified":1731409466300},{"_id":"themes/anzhiyu/source/css/_tags/Introduction-card.styl","hash":"12a3b3ad1e97d0a4fa63521c4eaf2b1025a95719","modified":1731409466301},{"_id":"themes/anzhiyu/source/css/_tags/bilbili.styl","hash":"e909f60fbbdcbd072fcb1a4c2eeafa237a13b6b0","modified":1731409466302},{"_id":"themes/anzhiyu/source/css/_tags/btns.styl","hash":"0e22fdd43f698d2b27999301ca2a8bb392ac04cf","modified":1731409466302},{"_id":"themes/anzhiyu/source/css/_tags/button.styl","hash":"ea2018ba7cbc2e11d413231556d5b001cdbd5117","modified":1731409466302},{"_id":"themes/anzhiyu/source/css/_tags/checkbox.styl","hash":"3f1fcb0973ccea197afef26e0d515b3800dae348","modified":1731409466302},{"_id":"themes/anzhiyu/source/css/_tags/folding.styl","hash":"f4c117ccd9ffec997a36347358050021e60df498","modified":1731409466303},{"_id":"themes/anzhiyu/source/css/_tags/gallery.styl","hash":"99f2edcee8318b8cf5911fe344b89f58df7f313c","modified":1731409466304},{"_id":"themes/anzhiyu/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1731409466304},{"_id":"themes/anzhiyu/source/css/_tags/hide.styl","hash":"4de1984c5fdf774ef2f8e856ea188729d06743b6","modified":1731409466304},{"_id":"themes/anzhiyu/source/css/_tags/image.styl","hash":"f0043e6d5542e63a919162a545fa228acc8e1ef9","modified":1731409466305},{"_id":"themes/anzhiyu/source/css/_tags/inline-labels.styl","hash":"25a32624cab8b623634bb797cde7f2c6baff5a15","modified":1731409466305},{"_id":"themes/anzhiyu/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1731409466305},{"_id":"themes/anzhiyu/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1731409466305},{"_id":"themes/anzhiyu/source/css/_tags/media.styl","hash":"da94e08918d1468871e69e265969d501310d3553","modified":1731409466306},{"_id":"themes/anzhiyu/source/css/_tags/note.styl","hash":"c991d29f0b970d4b738656501847cc70161dc594","modified":1731409466306},{"_id":"themes/anzhiyu/source/css/_tags/site-card.styl","hash":"d497a9c654b927e1579a8a8513573bafacc7150a","modified":1731409466306},{"_id":"themes/anzhiyu/source/css/_tags/span.styl","hash":"252220ebb7f8e3bbff620b4d254a4703dfea7f3e","modified":1731409466306},{"_id":"themes/anzhiyu/source/css/_tags/tabs.styl","hash":"ead8a25eb164a361990c8a4cef3afb45d9dc33d9","modified":1731409466306},{"_id":"themes/anzhiyu/source/css/_tags/timeline.styl","hash":"f538fe0525c6491ac24b23ae2f9c1d2c396494fd","modified":1731409466307},{"_id":"themes/anzhiyu/source/css/_tags/tip.styl","hash":"4682fa963d6e667e24fe35a18b5d351c640a2769","modified":1731409466307},{"_id":"themes/anzhiyu/source/css/_third-party/snackbar.styl","hash":"86a40c9b534498dadbf5076c1d6f84c030da5184","modified":1731409466308},{"_id":"themes/anzhiyu/source/css/_third-party/normalize.min.css","hash":"a1d57065668c1695a10032cea26dc4b5cd143690","modified":1731409466307},{"_id":"themes/anzhiyu/source/css/_third-party/twikoo.styl","hash":"1040ba99c7b14ca3d71e0e517310307376892af6","modified":1731409466308},{"_id":"themes/anzhiyu/source/img/friend/czc.jpg","hash":"15b5a9bd826d31818e10ced1758ec9a9b9ca53e4","modified":1731484349385},{"_id":"themes/anzhiyu/source/img/friend/hx.jpg","hash":"9ac6f5423643e8a325be60ed2a1277204badbc99","modified":1731484227984},{"_id":"themes/anzhiyu/source/img/friend/lz.jpg","hash":"a88ffa6499b1e4d14c0d46650703630f4643fbbe","modified":1731484124168},{"_id":"themes/anzhiyu/source/img/siteicon/16.png","hash":"8dc6ca32ff1264f7c1c3a8f62727a8c96ea7525b","modified":1731409466325},{"_id":"themes/anzhiyu/source/img/friend/zmh.jpg","hash":"e8bb09f1b2ffff8374e36373591035f68ed59e8b","modified":1731484548076},{"_id":"themes/anzhiyu/source/img/siteicon/apple-icon-180.png","hash":"7f580ec4819c9ef10b1306102152f4473f037a98","modified":1731409466326},{"_id":"themes/anzhiyu/source/img/siteicon/32.png","hash":"147aae33224066ef2a5987c3cbbfa4309c49cef4","modified":1731409466325},{"_id":"themes/anzhiyu/source/img/siteicon/manifest-icon-192.maskable.png","hash":"528b94ebcd34fb55436d64fdda76ef43ccbf031f","modified":1731409466326},{"_id":"themes/anzhiyu/source/img/siteicon/manifest-icon-512.maskable.png","hash":"6f8b4b3df8d1498db55a559f7106dc9b6e6af647","modified":1731409466326},{"_id":"themes/anzhiyu/source/js/anzhiyu/ai_abstract.js","hash":"c857f20164ed3efddc284bbf7ef56eee8cc37bcd","modified":1731409466327},{"_id":"themes/anzhiyu/source/js/anzhiyu/comment_barrage.js","hash":"1fb6922cb6d9345fc73d7f516c48a3799d7cdebd","modified":1731409466327},{"_id":"themes/anzhiyu/source/js/anzhiyu/random_friends_post.js","hash":"03b34e7fc4c0b5748f036a45e822be75b282b86c","modified":1731409466328},{"_id":"themes/anzhiyu/source/js/anzhiyu/people.js","hash":"c76d30b73f575cd9e0659600b05cf3819f20b17c","modified":1731409466328},{"_id":"themes/anzhiyu/source/js/anzhiyu/right_click_menu.js","hash":"0de57a2c37a799fec0979ea3195f4dd3827e9514","modified":1731409466328},{"_id":"themes/anzhiyu/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1731409466223},{"_id":"themes/anzhiyu/source/js/search/algolia.js","hash":"51bcf73660635454d66dd2b7a906caf69afa9518","modified":1731409466329},{"_id":"themes/anzhiyu/layout/includes/third-party/card-post-count/artalk.pug","hash":"32b1ec70a6e350c7839b50110a0949d39b827db8","modified":1731409466223},{"_id":"themes/anzhiyu/source/js/search/local-search.js","hash":"23e1b201d825afc1063b51031c5c172dfdeb49d4","modified":1731409466330},{"_id":"themes/anzhiyu/layout/includes/third-party/card-post-count/index.pug","hash":"5a6072e73874997e27dce1bf47f3d37922430336","modified":1731409466223},{"_id":"themes/anzhiyu/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1731409466223},{"_id":"themes/anzhiyu/layout/includes/third-party/card-post-count/waline.pug","hash":"6dd328b615f7ecf604fb0a1fbb1479e89674ea4b","modified":1731409466224},{"_id":"themes/anzhiyu/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1731409466224},{"_id":"themes/anzhiyu/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1731409466225},{"_id":"themes/anzhiyu/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1731409466225},{"_id":"themes/anzhiyu/layout/includes/third-party/chat/index.pug","hash":"085b6ec501eef02bb82157712cde35bf5cdf639e","modified":1731409466225},{"_id":"themes/anzhiyu/layout/includes/third-party/chat/tidio.pug","hash":"26bbedadf03ca8e1d8a8f1d39444cbe3413f8872","modified":1731409466226},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/artalk.pug","hash":"d3fc4c539bb4e70539ba0f90debd06791be28466","modified":1731409466226},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/giscus.pug","hash":"52db09844df436f026f6f0896190bdbf6f15a473","modified":1731409466226},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/index.pug","hash":"dffbe34a6030c9c4022928b3bdb7df71c93a0aa3","modified":1731409466227},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/js.pug","hash":"6bdb7e04d7e6c2a1608ad5a43866ced2fca9955e","modified":1731409466227},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/twikoo.pug","hash":"a60562048ff32bde1ceb8b5975158c85db2e16f2","modified":1731409466227},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/valine.pug","hash":"cfcbc39104ff3bb44bdb41d9b6dab8388005b750","modified":1731409466228},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/waline.pug","hash":"2fed41601733bf3b1a437aa40b9101987b9a95a2","modified":1731409466229},{"_id":"themes/anzhiyu/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1731409466231},{"_id":"themes/anzhiyu/layout/includes/third-party/math/katex.pug","hash":"65a432d2c54b9269ddaa68715dbcd8724ed32efb","modified":1731409466231},{"_id":"themes/anzhiyu/layout/includes/third-party/math/mermaid.pug","hash":"0b0123024cf64a23de92f9668d71f61558cf8f60","modified":1731409466232},{"_id":"themes/anzhiyu/layout/includes/third-party/newest-comments/artalk.pug","hash":"c46c9af5f626063aaafe5b0c027f4f6be06d4fcf","modified":1731409466232},{"_id":"themes/anzhiyu/layout/includes/third-party/newest-comments/index.pug","hash":"cb4021a8bbb4045c2ecca1a161921ea45fb1506f","modified":1731409466232},{"_id":"themes/anzhiyu/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"25b1e1cc5eca5a45f738071c3c66ca7a156b3740","modified":1731409466233},{"_id":"themes/anzhiyu/layout/includes/third-party/newest-comments/valine.pug","hash":"836d25b645aba02c7148547aed4a1be4f6146e07","modified":1731409466233},{"_id":"themes/anzhiyu/layout/includes/third-party/newest-comments/waline.pug","hash":"5aaffe9f673e5148493e14c84ceab50652e8a0e6","modified":1731409466233},{"_id":"themes/anzhiyu/layout/includes/third-party/runtime/runtime-js.pug","hash":"f76b4d84993a26e919bbc7cd531c5da5c5edd0c0","modified":1731409466235},{"_id":"themes/anzhiyu/layout/includes/third-party/search/docsearch.pug","hash":"4e0b2a779654022dff37f74aaad24e1f04280657","modified":1731409466235},{"_id":"themes/anzhiyu/layout/includes/third-party/search/algolia.pug","hash":"7d48985c136472a9a3170d4c57758bb275f6ec7b","modified":1731409466235},{"_id":"themes/anzhiyu/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1731409466236},{"_id":"themes/anzhiyu/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1731409466236},{"_id":"themes/anzhiyu/layout/includes/third-party/share/index.pug","hash":"a47fe41f39f0073d98baa72adbde87b2d1499049","modified":1731409466237},{"_id":"themes/anzhiyu/layout/includes/third-party/share/share-js.pug","hash":"b45fc15c3ae7db3a0fbce0d6da74a72a95ca8a2b","modified":1731409466237},{"_id":"themes/anzhiyu/layout/includes/third-party/search/local-search.pug","hash":"928accb5fb5978b851b1d19abcd464258dd10e06","modified":1731409466236},{"_id":"themes/anzhiyu/source/css/_extra/album/album.css","hash":"d79cc995aca04bb0072b206668a8530ff4bdacb6","modified":1731409466263},{"_id":"themes/anzhiyu/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1731409466232},{"_id":"themes/anzhiyu/source/css/_extra/album/album_detail.css","hash":"868db4e9e51e2bbe2d6555c957ecf56d50032c3c","modified":1731409466263},{"_id":"themes/anzhiyu/source/css/_extra/aside_weixin/aside_weixin.css","hash":"a96b0559ca915f2aa1f2a80412bb75cfce6fea38","modified":1731409466264},{"_id":"themes/anzhiyu/source/css/_extra/anzhiyu/custom.css","hash":"262291db00a343991c5472131804a4fd00deed4f","modified":1731409466264},{"_id":"themes/anzhiyu/source/css/_extra/categoryBar/categoryBar.css","hash":"07ef90cb816c5fef8114031bfbe7f7741b6b9b98","modified":1731409466265},{"_id":"themes/anzhiyu/source/css/_extra/catalog_list/catalog_list.css","hash":"027a9fb2d501c82d4bb6d69e2e76a7fa8be27f11","modified":1731409466265},{"_id":"themes/anzhiyu/source/css/_extra/code/code.css","hash":"bb9e145a87748f2db0441ab2ea79ef4a7e03356e","modified":1731409466267},{"_id":"themes/anzhiyu/source/css/_extra/code/details_summary.css","hash":"71d98974fca9d899bcb5c429b3ab3e9e1cb88bba","modified":1731409466268},{"_id":"themes/anzhiyu/source/css/_extra/clock/clock.css","hash":"581be0a5214a5534e4cf81ceb3184737e5f2d987","modified":1731409466265},{"_id":"themes/anzhiyu/source/css/_extra/commentBarrage/commentBarrage.css","hash":"335861ca0fc4aa4be700b769c871038743ea95dd","modified":1731409466268},{"_id":"themes/anzhiyu/source/css/_extra/console/console.css","hash":"0c22c5c2a004b09bb913ce52caf7ff115c8d7ef5","modified":1731409466269},{"_id":"themes/anzhiyu/source/css/_extra/essay_page/essay_page.css","hash":"99d7a0fece8d6e69da5ba570acb77016e92113fd","modified":1731409466269},{"_id":"themes/anzhiyu/source/css/_extra/essay_page/home_essay_bar.css","hash":"69c4c9acd4a42c6fad4bb507e45cf01b5f0aa37b","modified":1731409466269},{"_id":"themes/anzhiyu/source/css/_extra/fix/aplayer.css","hash":"d8beefb88560e30178b8baab596791e51b4d5451","modified":1731409466270},{"_id":"themes/anzhiyu/source/css/_extra/fix/bilibili-bangumi.css","hash":"0cb28adec6878ebd7a9372f289e21280b2bc7259","modified":1731409466270},{"_id":"themes/anzhiyu/source/css/_extra/fix/bilibili-ratio.css","hash":"628352103e72c98e6d2b25f1cdb39070bd0f021c","modified":1731409466270},{"_id":"themes/anzhiyu/source/css/_extra/fix/categories.css","hash":"b6f7f3e384f0497926ffda4a6db1ccfc90307651","modified":1731409466271},{"_id":"themes/anzhiyu/source/css/_extra/fix/clock.css","hash":"adb0616fdb157a880d1ab01bfb51e522df8c3523","modified":1731409466271},{"_id":"themes/anzhiyu/source/css/_extra/fix/comments.css","hash":"7c2a30ceeb7519c96eda1c2ef67b6873ba3f24d2","modified":1731409466271},{"_id":"themes/anzhiyu/source/css/_extra/fix/dark.css","hash":"dfc609b95f31544177babc76dade1720fe7cda42","modified":1731409466272},{"_id":"themes/anzhiyu/source/css/_extra/fix/fcircle_page.css","hash":"16833b57f9dbb1d72cdf4a3cd80751a315a0bb27","modified":1731409466272},{"_id":"themes/anzhiyu/source/css/_extra/fix/gitcalendar.css","hash":"b3081e90ff9994e0ed0206065bbb07daa90d6e29","modified":1731409466273},{"_id":"themes/anzhiyu/source/css/_extra/fix/hexo-tag-dplayer.css","hash":"7ded42d62e0ba475b9789977ed7236a6c1b32007","modified":1731409466273},{"_id":"themes/anzhiyu/source/css/_extra/fix/hide-block.css","hash":"cb6319200511548acd5642f4c6d9a3115a778b35","modified":1731409466273},{"_id":"themes/anzhiyu/source/css/_extra/fix/link_page.css","hash":"ced162602659f3cb0e423ef15c532cc7c99d6123","modified":1731409466273},{"_id":"themes/anzhiyu/source/css/_extra/fix/overflow.css","hash":"b2dafcb1bc1fa4c06f648245f11acdaf7a878d05","modified":1731409466273},{"_id":"themes/anzhiyu/source/css/_extra/fix/radius.css","hash":"a55321b326f241d0788359d5366172d7aeb734e1","modified":1731409466274},{"_id":"themes/anzhiyu/source/css/_extra/fix/site-card.css","hash":"f56eff8b96c773ae6a8e97ef0e1c822feabe5854","modified":1731409466274},{"_id":"themes/anzhiyu/source/css/_extra/footer/footer.css","hash":"497980fa313ff7045c0756a32dc08101dcc3013d","modified":1731409466274},{"_id":"themes/anzhiyu/source/css/_extra/friends/friends.css","hash":"171868650c64cb995cfab069b3c128b5d07e3d38","modified":1731409466275},{"_id":"themes/anzhiyu/source/css/_extra/greeting_box/greeting_box.css","hash":"9c54f33a8f22064e803b2a8324f93549021f5aa4","modified":1731409466275},{"_id":"themes/anzhiyu/source/css/_extra/home_top/categorygroup.css","hash":"b38d1dd55da2ff3e18e32628a5484e46e880d6b9","modified":1731409466275},{"_id":"themes/anzhiyu/source/css/_extra/home_top/home_top.css","hash":"954a9eca322a5eb3fd04ad5a71f61927b0c35400","modified":1731409466276},{"_id":"themes/anzhiyu/source/css/_extra/home_top/home_top_post_group.css","hash":"4f60d12d4f174453223be2070ed608de4ad5d14d","modified":1731409466276},{"_id":"themes/anzhiyu/source/css/_extra/home_top/swiperstyle.css","hash":"33f5a0731ac439871dd54aad7528431df091b551","modified":1731409466277},{"_id":"themes/anzhiyu/source/css/_extra/home_top/top_group_banner.css","hash":"4b3090b0f5f01dbd4b1706e4104962b15c05f8d0","modified":1731409466278},{"_id":"themes/anzhiyu/source/css/_extra/local_search/local_search.css","hash":"9fc79ed81a5f0476172fe688ecba08e7b8e3be03","modified":1731409466278},{"_id":"themes/anzhiyu/source/css/_extra/reset/reset.css","hash":"4651067de360b4e00dd361795a74a7ed2a5a62ff","modified":1731409466279},{"_id":"themes/anzhiyu/source/css/_extra/room/room.css","hash":"5a730fdec4fd9e1d8b38e407ba1d139abd6a17d2","modified":1731409466280},{"_id":"themes/anzhiyu/source/css/_extra/reward/about-reward.css","hash":"2201faa78b7a9ded910f59abe28df2b897fd23b0","modified":1731409466279},{"_id":"themes/anzhiyu/source/css/_extra/runtime/runtime.css","hash":"6e8dbcf6e505cd96192c8b75970ff65f98acf51c","modified":1731409466280},{"_id":"themes/anzhiyu/source/css/_extra/skills/skills.css","hash":"12901c0c77345fbd92edf591ee98266919eed259","modified":1731409466281},{"_id":"themes/anzhiyu/source/css/_extra/single_card/single_card.css","hash":"f7690f0dde69437f2222a9889ea957a185a7fbb6","modified":1731409466280},{"_id":"themes/anzhiyu/source/css/_extra/tag/link.css","hash":"da429802cbe2cf45b66115d03c682e9463c34dc1","modified":1731409466281},{"_id":"themes/anzhiyu/source/css/_extra/tag/site.css","hash":"8735ce339b410a72fc314af37f5d7ffd783fad05","modified":1731409466281},{"_id":"themes/anzhiyu/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1731409466286},{"_id":"themes/anzhiyu/source/css/_highlight/highlight/index.styl","hash":"58680cd4ff5767afeabe4d4cfb621c0c2d7a68e4","modified":1731409466286},{"_id":"themes/anzhiyu/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1731409466287},{"_id":"themes/anzhiyu/source/css/_highlight/prismjs/index.styl","hash":"78398d5c407a30a561c1c98baccaabd9633edd27","modified":1731409466287},{"_id":"themes/anzhiyu/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1731409466287},{"_id":"themes/anzhiyu/source/img/friend/lyr.png","hash":"25e5f27bd0789905bd864d6749567af2a4241fb2","modified":1731482054470},{"_id":"themes/anzhiyu/source/img/404.jpg","hash":"030b9c7c9d654b3d67c1249a6e5900bf40c79373","modified":1731409466310},{"_id":"themes/anzhiyu/source/img/friend/cc.png","hash":"afc051eb4087c13773207e78ffdf4a02abd1bd1d","modified":1731482478554},{"_id":"themes/anzhiyu/source/img/friend/ljj.png","hash":"7f2600ad8d8f847c51655a4e836c1155ec0e9c62","modified":1731484457553},{"_id":"themes/anzhiyu/source/img/friend_404.gif","hash":"4c0a482bce3710942aff900d62c48333827e5a53","modified":1731409466319},{"_id":"themes/anzhiyu/source/img/loading.gif","hash":"b9e8d78b86bc48d565e26c8c1ea275c2c758fb0d","modified":1731409466324},{"_id":"themes/anzhiyu/source/img/roadNetwork.png","hash":"acc39da17d6989d22cb9d5fc7a27edcbaffa51c6","modified":1731412911040},{"_id":"public/sitemap.xml","hash":"988818f121776c88540e2f3e49ec5dfb1ab85e3c","modified":1732197594588},{"_id":"public/sitemap.txt","hash":"b6d8060a515ea39fc26c786e5d4e979fd1cbca2d","modified":1732197594588},{"_id":"public/anzhiyu/random.js","hash":"0d86868a7c332cef66b3f98f84986c0e1c8c7958","modified":1732196187182},{"_id":"public/404.html","hash":"d7c6768fff8154f1a37480d6034ad21466a3ce36","modified":1732197594588},{"_id":"public/about/index.html","hash":"88a4a45c0e888f3c2fa3fcaaf36d390fa13098bc","modified":1732196187182},{"_id":"public/tags/index.html","hash":"ae37728b10a99b28c3b75679a09fc3ff601c4435","modified":1732196187182},{"_id":"public/categories/index.html","hash":"3ebfb9b2f940cd466d22bf001f346a5e8972d74f","modified":1732196187182},{"_id":"public/link/index.html","hash":"33390f3869f376230519aa4bc35015db8f5b42de","modified":1732196187182},{"_id":"public/2024/11/18/Parquet/index.html","hash":"2ad65b8d2be993896382b31e3862bd1a090e3664","modified":1732197594588},{"_id":"public/2024/11/12/使用Python提取城市路网/index.html","hash":"ddb35a968d48f0394402905398b2de530e0ba9d6","modified":1732197594588},{"_id":"public/archives/2024/index.html","hash":"8ac471cadd4b99436fda9576927cbac5c32f9180","modified":1732197594588},{"_id":"public/archives/2024/11/index.html","hash":"65e68ffd0b761d4b294612f56944e93c553be003","modified":1732197594588},{"_id":"public/archives/index.html","hash":"9bbacb69293dbe49eb4c624a946fc81dabb40a64","modified":1732197594588},{"_id":"public/categories/大数据/index.html","hash":"4a629bd711b5b552b64b076d4951f9a41621515c","modified":1732197594588},{"_id":"public/index.html","hash":"36e1ba0e7676d0190e44620d52f676c505a9b0c7","modified":1732197594588},{"_id":"public/categories/时空数据/index.html","hash":"a4e1d66d524f616e700fdbce229f9c747b48696c","modified":1732197594588},{"_id":"public/tags/parquet/index.html","hash":"6553d4474d1716dd2f72aa7715097887a9f6c4fd","modified":1732197594588},{"_id":"public/tags/Python/index.html","hash":"5a7cbdf0e98fb178c8bae3ad33a9aa42d7d2f05e","modified":1732197594588},{"_id":"public/tags/文件存储/index.html","hash":"d4b4e410cc21ffb54228c414881dc1a0638cfd3d","modified":1732197594588},{"_id":"public/tags/路网/index.html","hash":"b89fb541e809b3a25994d26e91476a2888256b9d","modified":1732197594588},{"_id":"public/images/format.png","hash":"a71da3ce97ed80edb5a75712c2f057953e3b44e3","modified":1732196187182},{"_id":"public/images/schema.png","hash":"773d46dc6e9b1895b16a2724f336913458a2d232","modified":1732196187182},{"_id":"public/images/cover_image/parquet.png","hash":"94138cbd8604ccdf5b7635df170ac4fba275bc88","modified":1732196187182},{"_id":"public/img/512.png","hash":"6988b23a31304d9de45b95a1e7c05dd42024e560","modified":1732196187182},{"_id":"public/favicon.ico","hash":"14310db268ea8d3b2096f434c6e293fc207f5f09","modified":1732196187182},{"_id":"public/49890814.jpg","hash":"ecdf539191760a2e1210a843c8b43b5342d6b947","modified":1732196187182},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1732196187182},{"_id":"public/img/default_cover.jpg","hash":"455fa65e2736f61ac36360dd4f76fc1ab6a1cdd5","modified":1732196187182},{"_id":"public/img/favicon.ico","hash":"14310db268ea8d3b2096f434c6e293fc207f5f09","modified":1732196187182},{"_id":"public/img/comment_bg.png","hash":"91612a887446fb436e9151981e2289f2a426a3e5","modified":1732196187182},{"_id":"public/img/friend/czc.jpg","hash":"15b5a9bd826d31818e10ced1758ec9a9b9ca53e4","modified":1732196187182},{"_id":"public/img/friend/hx.jpg","hash":"9ac6f5423643e8a325be60ed2a1277204badbc99","modified":1732196187182},{"_id":"public/img/friend/lz.jpg","hash":"a88ffa6499b1e4d14c0d46650703630f4643fbbe","modified":1732196187182},{"_id":"public/img/friend/zmh.jpg","hash":"e8bb09f1b2ffff8374e36373591035f68ed59e8b","modified":1732196187182},{"_id":"public/img/siteicon/16.png","hash":"8dc6ca32ff1264f7c1c3a8f62727a8c96ea7525b","modified":1732196187182},{"_id":"public/img/siteicon/32.png","hash":"147aae33224066ef2a5987c3cbbfa4309c49cef4","modified":1732196187182},{"_id":"public/img/siteicon/apple-icon-180.png","hash":"7f580ec4819c9ef10b1306102152f4473f037a98","modified":1732196187182},{"_id":"public/img/siteicon/manifest-icon-192.maskable.png","hash":"528b94ebcd34fb55436d64fdda76ef43ccbf031f","modified":1732196187182},{"_id":"public/img/siteicon/manifest-icon-512.maskable.png","hash":"6f8b4b3df8d1498db55a559f7106dc9b6e6af647","modified":1732196187182},{"_id":"public/images/metadata.png","hash":"cb74b8b1ff9272d06cb718f720344b22b2b8129c","modified":1732196187182},{"_id":"public/img/friend/lyr.png","hash":"25e5f27bd0789905bd864d6749567af2a4241fb2","modified":1732196187182},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732196187182},{"_id":"public/css/index.css","hash":"1efacc7c6fff332251528c8cf07a11d62910bc08","modified":1732196187182},{"_id":"public/js/utils.js","hash":"68e7f87c38365ef1271b69943395aa5fdb5417ea","modified":1732196187182},{"_id":"public/js/main.js","hash":"888563ad7324e565e6f5060ca126d69c7309bef1","modified":1732196187182},{"_id":"public/js/anzhiyu/ai_abstract.js","hash":"be52eb13a416b18337d3b1142277920072e698c3","modified":1732196187182},{"_id":"public/js/anzhiyu/comment_barrage.js","hash":"1b30f922238f626c6a90ce2705789ba2362a2a9e","modified":1732196187182},{"_id":"public/js/tw_cn.js","hash":"6cbec565e98cbd49aa75e6161d8fa996ae3be91a","modified":1732196187182},{"_id":"public/js/anzhiyu/people.js","hash":"f3d2a3d0c730124d9f64dbf59486145c05a42ac6","modified":1732196187182},{"_id":"public/js/search/algolia.js","hash":"5c2a0d0489c51c6d9e54f5a3b0c6e66a5f649450","modified":1732196187182},{"_id":"public/js/anzhiyu/right_click_menu.js","hash":"d605ee0cab24604f97ccef5747bfacaa108645ba","modified":1732196187182},{"_id":"public/js/search/local-search.js","hash":"3ad66c75b4a0fc28a14a5478ee8a19fde72f837f","modified":1732196187182},{"_id":"public/js/anzhiyu/random_friends_post.js","hash":"1548fdc0a8cb4291bc8793dc8d321c59c097c08e","modified":1732196187182},{"_id":"public/img/404.jpg","hash":"030b9c7c9d654b3d67c1249a6e5900bf40c79373","modified":1732196187182},{"_id":"public/img/friend/cc.png","hash":"afc051eb4087c13773207e78ffdf4a02abd1bd1d","modified":1732196187182},{"_id":"public/img/friend/ljj.png","hash":"7f2600ad8d8f847c51655a4e836c1155ec0e9c62","modified":1732196187182},{"_id":"public/img/friend_404.gif","hash":"4c0a482bce3710942aff900d62c48333827e5a53","modified":1732196187182},{"_id":"public/img/loading.gif","hash":"b9e8d78b86bc48d565e26c8c1ea275c2c758fb0d","modified":1732196187182},{"_id":"public/img/roadNetwork.png","hash":"acc39da17d6989d22cb9d5fc7a27edcbaffa51c6","modified":1732196187182},{"_id":"source/images/cover_image/parquet.jpg","hash":"51eb4f0237da0575f6d62c4b07d14fc3be3e1648","modified":1732197396373},{"_id":"public/images/cover_image/parquet.jpg","hash":"51eb4f0237da0575f6d62c4b07d14fc3be3e1648","modified":1732197433317}],"Category":[{"name":"时空数据","_id":"cm3rcvwhl0006usb0ev9i8v3g"},{"name":"大数据","_id":"cm3rcvwhp0008usb03or5duke"}],"Data":[{"_id":"about","data":[{"class_name":"关于页","subtitle":"干就完了✨","avatarImg":"/49890814.jpg","avatarSkills":{"left":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙"],"right":["专修交互与设计 🤝","脚踏实地行动派 🏃","团队小组发动机 🧱","壮汉人狠话不多 💢"]},"name":"孙杨洋","description":"重庆大学 硕士研究生","aboutsiteTips":{"tips":"追求","title1":"源于","title2":"热爱而去 感受","word":["学习","生活","程序","体验"]},"helloAbout":"Hello world!","skillsTips":{"tips":"技能","title":"开启创造力"},"careers":{"tips":"生涯","title":"无限进步","list":[{"desc":"EDU,软件工程专业","color":"#357ef5"},{"desc":"EDU,软件工程专业","color":"#357ef5"},{"desc":"EDU,软件工程专业","color":"#357ef5"}],"img":"https://bu.dusays.com/2023/04/21/644287166329b.png"},"statistic":{"link":"/archives","text":"文章隧道","cover":"https://bu.dusays.com/2023/05/01/644f4b037b930.jpg"},"map":{"title":"我现在住在","StrengthenTitle":"中国，重庆市","background":"https://bu.dusays.com/2023/07/05/64a4c61cb20ef.jpg","backgroundDark":"https://bu.dusays.com/2023/07/05/64a4c63495ac5.jpg"},"selfInfo":{"selfInfoTips1":"生于","selfInfoContentYear":2000,"selfInfoTips2":"重庆大学","selfInfoContent2":"计算机科学与技术","selfInfoTips3":"现在职业","selfInfoContent3":"研究生三年级学生👨‍🎓"},"personalities":{"author_name":"执政官","personality_type":"ESFJ-A","photo_url":"https://bu.dusays.com/2023/07/05/64a4c63495ac5.jpg","personality_img":"https://npm.elemecdn.com/anzhiyu-blog@2.0.8/img/svg/ESFJ-A.svg","name_url":"https://www.16personalities.com/ch/esfj-%E4%BA%BA%E6%A0%BC"},"maxim":{"maxim_tips":"座右铭","maxim_top":"干就完了，","maxim_bottom":"干就完了。"},"buff":{"buff_tips":"特长","buff_top":"脑回路新奇的 酸菜鱼","buff_bottom":"二次元指数 MAX"},"game":{"game_tips":"爱好游戏","game_title":"原神","game_uid":"UID: 125766904","game_bg":"https://bu.dusays.com/2023/04/22/64433bf26e25d.webp"},"comic":{"comic_tips":"爱好番剧","comic_title":"追番","comic_list":[{"name":"约定的梦幻岛","href":"https://www.bilibili.com/bangumi/media/md5267750/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1","cover":"https://bu.dusays.com/2023/05/27/647166c44b414.webp"},{"name":"咒术回战","href":"https://www.bilibili.com/bangumi/media/md28229899/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1","cover":"https://bu.dusays.com/2023/05/24/646db4398832e.webp"},{"name":"紫罗兰永恒花园","href":"https://www.bilibili.com/bangumi/media/md8892/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1","cover":"https://bu.dusays.com/2023/05/24/646db43983d99.webp"},{"name":"鬼灭之刃","href":"https://www.bilibili.com/bangumi/media/md22718131/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1","cover":"https://bu.dusays.com/2023/05/24/646db439856a0.webp"},{"name":"JOJO的奇妙冒险 黄金之风","href":"https://www.bilibili.com/bangumi/media/md135652/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1","cover":"https://bu.dusays.com/2023/05/30/64760e38d651a.webp"}]},"like":{"like_tips":"关注偏好","like_title":"数码科技","like_bg":"https://bu.dusays.com/2022/12/06/638f5f05ce1f7.jpg","like_bottom":"手机、电脑软硬件"}}]},{"_id":"creativity","data":[{"class_name":"开启创造力","creativity_list":[{"name":"Java","color":"#fff","icon":"https://bu.dusays.com/2023/04/09/643293b1184e9.jpg"},{"name":"Docker","color":"#57b6e6","icon":"https://bu.dusays.com/2023/04/09/643293b0f0abe.png"},{"name":"Photoshop","color":"#4082c3","icon":"https://bu.dusays.com/2022/12/15/639aa3a5c240e.png"},{"name":"Node","color":"#333","icon":"https://npm.elemecdn.com/anzhiyu-blog@2.1.1/img/svg/node-logo.svg"},{"name":"Webpack","color":"#2e3a41","icon":"https://bu.dusays.com/2023/04/09/643293b68026c.png"},{"name":"Pinia","color":"#fff","icon":"https://npm.elemecdn.com/anzhiyu-blog@2.0.8/img/svg/pinia-logo.svg"},{"name":"Python","color":"#fff","icon":"https://bu.dusays.com/2023/04/09/643293b1230f7.png"},{"name":"Vite","color":"#937df7","icon":"https://npm.elemecdn.com/anzhiyu-blog@2.0.8/img/svg/vite-logo.svg"},{"name":"Flutter","color":"#4499e4","icon":"https://bu.dusays.com/2023/04/09/643293b1055c2.png"},{"name":"Vue","color":"#b8f0ae","icon":"https://bu.dusays.com/2023/04/09/643293b6788bd.png"},{"name":"React","color":"#222","icon":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9Ii0xMS41IC0xMC4yMzE3NCAyMyAyMC40NjM0OCI+CiAgPHRpdGxlPlJlYWN0IExvZ288L3RpdGxlPgogIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSIyLjA1IiBmaWxsPSIjNjFkYWZiIi8+CiAgPGcgc3Ryb2tlPSIjNjFkYWZiIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIi8+CiAgICA8ZWxsaXBzZSByeD0iMTEiIHJ5PSI0LjIiIHRyYW5zZm9ybT0icm90YXRlKDYwKSIvPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIiB0cmFuc2Zvcm09InJvdGF0ZSgxMjApIi8+CiAgPC9nPgo8L3N2Zz4K"},{"name":"CSS3","color":"#2c51db","icon":"https://bu.dusays.com/2022/12/15/639aa3a5c251e.png"},{"name":"JS","color":"#f7cb4f","icon":"https://bu.dusays.com/2023/04/09/643293b121f02.png"},{"name":"HTML","color":"#e9572b","icon":"https://bu.dusays.com/2022/12/15/639aa3a5c241c.png"},{"name":"Git","color":"#df5b40","icon":"https://bu.dusays.com/2023/04/09/643293b10ccdd.webp"},{"name":"Apifox","color":"#e65164","icon":"https://bu.dusays.com/2022/11/19/6378d6458c6b6.png"}]}]},{"_id":"link","data":[{"class_name":"导师","class_desc":"大佬们！","flink_style":"anzhiyu","hundredSuffix":"","link_list":[{"name":"李瑞远","link":"http://www.kangry.net/blog/?type=about-me","avatar":"/img/friend/lyr.png","descr":"时空数据管理与挖掘，数据库","recommend":true},{"name":"陈超","link":"https://faculty.cqu.edu.cn/ChaoChen/zh_CN/index.htm","avatar":"/img/friend/cc.png","descr":"智能无人系统，城市计算","recommend":true}]},{"class_name":"小伙伴","class_desc":"那些人，那些事","flink_style":"anzhiyu","hundredSuffix":"","link_list":[{"name":"李政","link":"https://lizhzz.github.io/","avatar":"/img/friend/lz.jpg","descr":"数据压缩，时空数据管理","recommend":true},{"name":"何翔","link":"https://cquhx.github.io/","avatar":"/img/friend/hx.jpg","descr":"美团大佬，时空关键字查询","recommend":true},{"name":"陈泽超","link":"https://blog.ackth.cc/about/","avatar":"/img/friend/czc.jpg","descr":"未来的院士？ 大模型之神","recommend":true},{"name":"李佳俊","link":"https://ewainliu.github.io/jiajunli.io/","avatar":"/img/friend/ljj.png","descr":"古希腊掌管五花肉的神？ AI4DB","recommend":true},{"name":"朱明辉","link":"https://jjjupiterrr.github.io/AboutMe/","avatar":"/img/friend/zmh.jpg","descr":"数据压缩，轨迹查询","recommend":true}]},{"class_name":"推荐博客","flink_style":"telescopic","hundredSuffix":"","link_list":[{"name":"安知鱼","link":"https://blog.anheyu.com/","avatar":"https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg","descr":"生活明朗，万物可爱","siteshot":"https://npm.elemecdn.com/anzhiyu-theme-static@1.1.6/img/blog.anheyu.com.jpg","color":"vip","tag":"技术"}]}]}],"Page":[{"title":"关于","date":"2024-11-12T07:57:51.000Z","aside":false,"top_img":false,"background":"#f8f9fe","comments":0,"type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2024-11-12 15:57:51\naside: false\ntop_img: false\nbackground: \"#f8f9fe\"\ncomments: false\ntype: \"about\"\n---\n","updated":"2024-11-13T10:15:39.378Z","path":"about/index.html","layout":"page","_id":"cm3rcvwh20000usb0go570it4","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"title":"标签","date":"2024-11-12T04:01:51.000Z","type":"tags","comments":0,"top_img":false,"_content":"\n","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2024-11-12 12:01:51\ntype: \"tags\"\ncomments: false\ntop_img: false\n---\n\n","updated":"2024-11-12T12:06:48.493Z","path":"tags/index.html","layout":"page","_id":"cm3rcvwh50001usb0azno87nc","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"title":"分类","date":"2024-11-12T09:56:00.000Z","aside":false,"top_img":false,"type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2024-11-12 17:56:00\naside: false\ntop_img: false\ntype: \"categories\"\n---\n","updated":"2024-11-12T09:19:00.894Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cm3rcvwh50002usb034rz162m","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"title":"link","date":"2024-11-13T07:09:50.000Z","type":"link","_content":"\n\n","source":"link/index.md","raw":"---\ntitle: link\ndate: 2024-11-13 15:09:50\ntype: \"link\"\n---\n\n\n","updated":"2024-11-13T07:10:31.420Z","path":"link/index.html","comments":1,"layout":"page","_id":"cm3rcvwh50003usb018bj9qwf","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"使用Python提取城市路网","date":"2024-11-12T03:10:45.000Z","cover":"/img/roadNetwork.png","sticky":1,"_content":"# 路网提取教程V1.0\n## 一.基于Python的路网提取\n### 1.1 环境准备\n#### 1.1.1 Python的安装\nPython下载：https://www.python.org/ （确保安装pip，如果希望环境分离可以安装conda：https://www.anaconda.com/download ）\\\nPycharm下载：https://www.jetbrains.com/zh-cn/pycharm/ (建议安装jupter插件进行交互式编写)\n#### 1.1.2 必要的Python包的安装\n```python\npip install osmnx geopandas pandas numpy shapely\n```\n- **osmnx** 是一个基于 OpenStreetMap 数据的 Python 库，用于从 OpenStreetMap 获取、构建、分析和可视化街道网络和其他地理空间数据。通过 osmnx，我们可以轻松地检索全球范围内的街道网络数据，并进行各种空间分析，如路网分析、路径规划和空间可视化。\n- **Pandas**（Python Data Analysis Library）是一个提供高性能、易于使用的数据结构和数据分析工具的Python库。它主要用于数据处理和数据分析，可以处理各种数据格式，如CSV文件、Excel表格、SQL数据库等，提供了丰富的数据操作和处理功能。\n- **NumPy**（Numerical Python）是Python中用于科学计算的一个核心库。它提供了多维数组对象（例如ndarray）、各种派生对象（例如masked arrays和matrices）、以及用于数组快速操作的各种函数。NumPy是许多其他科学计算库的基础，因为它提供了高效的数组操作和运算功能。\n- **Geopandas** 是在Pandas基础上扩展的地理空间数据处理库，提供了地理空间数据结构和方便的数据操作功能。它使得在 Python 中处理地理空间数据变得简单和高效，可以处理各种地理空间数据格式，如Shapefile、GeoJSON等，并提供了空间数据的分析和可视化功能。\n- **Shapely** 是一个 Python 库，用于处理几何对象，如点、线和多边形。它提供了创建、分析和操作这些对象的功能，可用于地理空间数据处理和分析。Shapely 简化了空间数据的操作，使得在Python中处理地理信息变得更加简单和高效。\n- **math** 是 Python 标准库中的一个模块，提供了许多数学函数和常量。\n\n#### 1.1.3 导入Python包\n```python\nimport osmnx as ox\nimport geopandas as gpd\nimport pandas as pd\nimport numpy as np\nimport geopandas as gpd\nfrom shapely import wkt\nfrom shapely.geometry import LineString\nimport math\n```\n### 1.2 路网的提取\n#### 1.2.1 根据城市名称获取路网\n```python\nplace_name = \"Chendu, China\"\ngraph = ox.graph_from_place(place_name, network_type='drive')\n```\nplace_name指定城市位置（格式为城市，国家），graph是根据位置获得的路网图，类型为多图。\n#### 1.2.2 根据经纬度边界获取路网\n```python\nnorth, south, east, west = 30.67, 30.65, 104.07, 104.05\ngraph = ox.graph_from_bbox(north, south, east, west, network_type='drive')\n```\nnorth, south, east, west指定经纬度的边界（四个参数亦可以使用bbox代替），graph是根据位置获得的路网图，类型为多图。\n#### 1.2.3 其他获取路网的方式\n其他获取路网的方式请参考：https://github.com/gboeing/osmnx\n### 1.3 路网的处理\n#### 1.3.1 提取节点与边\n```python\ngdf_nodes, gdf_edges = ox.graph_to_gdfs(graph)\n```\ngdf_nodes是点的集合，gdf_edges是边的集合，它们的类型都是GeoDataFrame，包含字段见下表：\n\n**gdf_nodes**：\n\n| 字段名        | 解释            | 数据类型 |\n|--------------|-----------------|---------|\n| y            | 纬度            | double   |\n| x            | 经度            | double   |\n| street_count | 包含点的路段数量 | int      |\n| highway      | 道路类型        | string   |\n| geometry     | 几何形状        | Point    |\n\n**gdf_edges**：\n\n| 字段名        | 解释             | 数据类型  |\n|--------------|----------------- |-----------|\n| u (index)    | 起点id           | double    |\n| v (index)    | 终点id           | double    |\n| key (index)  | 权重             | int       |\n| osmid        | 道路osmID        | List(long)|\n| oneway       | 是否单向         | boolean   |\n| highway      | 道路类型         | string    |\n| reversed     | 是否反转         | boolean   |\n| length       | 路段长度         | double    |\n| geometry     | 几何形状         | LineString |\n| lanes        | 车道数量         | int       |\n| ref          | 道路编码         | string    |\n| name         | 道路名称         | string    |\n| brigde       | 是否桥梁         | string(Yes/No/NaN) |\n| tunnel       | 是否隧道         | string(Yes/No/NaN) |\n| maxspeed     | 最大限速         | int       |\n| junction     | 路口类型         | string    |\n| access       | 使用权           | string    |\n| width        | 道路宽度         | double    |\n| landuse      | 土地利用         | string    |\n\n为提取路网，我们需要使用到gdf_edges中的u,v获取路段的起点与终点，通过oneway字段与reversed确定路段方向,通过length获取路段长度。\n\n#### 1.3.2 取消索引并生成唯一id\n```python\ngdf_edges.reset_index(inplace=True)\ngdf_edges['id']=np.arange(gdf_edges.shape[0])\n```\n#### 1.3.3 更具路网的字段确定需要处理的列\n假设路网的字段为：起点id，终点id，路段长度，路段方向（未定义-1，双向1，正向2，反向3），路段等级，路段限速。\n```python\n#添加需要处理的列\ngdf_edges['start_id'] = gdf_edges['u']\ngdf_edges['end_id'] = gdf_edges['v']\ngdf_edges['lengthInMeter'] = gdf_edges['length']\ngdf_edges['direction'] = -1\ngdf_edges['level'] = 1\ngdf_edges['speed_limit'] = gdf_edges['maxspeed']\n#根据条件设置 direction 列的值\ngdf_edges['direction'] = gdf_edges.apply(lambda row: 2 if row['oneway'] == True and row['reversed'] == False else (3 if row['oneway'] == True and row['reversed'] == True else 1), axis=1)\n#速度限制取最大值\ngdf_selected['speed_limit'] = gdf_selected['speed_limit'].apply(lambda x: x if isinstance(x, int) else max(x))\n```\n#### 1.3.4 成功新生成路段起点与终点id\n```python\n# 合并两列并找出所有唯一值\nunique_values = pd.concat([gdf_edges['start_id'], gdf_edges['end_id']]).unique()\n# 为每个唯一值生成编号，格式为 \"t_n\"\nvalue_to_id = {val: f\"t_{i+1}\" for i, val in enumerate(unique_values)}\n# 更新DataFrame中的列\ngdf_edges['start_id'] = gdf_edges['start_id'].map(value_to_id)\ngdf_edges['end_id'] = gdf_edges['end_id'].map(value_to_id)\n# 去除 't_' 前缀\ngdf_edges['start_id'] = gdf_edges['start_id'].str.replace('t_', '')\ngdf_edges['end_id'] = gdf_edges['end_id'].str.replace('t_', '')\n```\n#### 1.3.5 异常值的处理\n```python\n#空值的填充\ngdf_edges = gdf_edges.fillna(0)\n```\n#### 1.3.6 路网数据的存储\n```python\ngdf_selected = gdf_edges[['index', 'geometry', 'start_id', 'end_id', 'direction', 'level' , 'speed_limit','lengthInMeter']]\ngdf_selected.to_csv('outputchengdu.csv', sep='|', index=False)\n```\n其中分隔符设置为\"|\"，不存储索引。","source":"_posts/使用Python提取城市路网.md","raw":"---\ntitle: 使用Python提取城市路网\ndate: 2024-11-12 11:10:45\ntags:\n  - 路网\n  - Python\ncategories: \n  - 时空数据\ncover: /img/roadNetwork.png\nsticky: 1\n---\n# 路网提取教程V1.0\n## 一.基于Python的路网提取\n### 1.1 环境准备\n#### 1.1.1 Python的安装\nPython下载：https://www.python.org/ （确保安装pip，如果希望环境分离可以安装conda：https://www.anaconda.com/download ）\\\nPycharm下载：https://www.jetbrains.com/zh-cn/pycharm/ (建议安装jupter插件进行交互式编写)\n#### 1.1.2 必要的Python包的安装\n```python\npip install osmnx geopandas pandas numpy shapely\n```\n- **osmnx** 是一个基于 OpenStreetMap 数据的 Python 库，用于从 OpenStreetMap 获取、构建、分析和可视化街道网络和其他地理空间数据。通过 osmnx，我们可以轻松地检索全球范围内的街道网络数据，并进行各种空间分析，如路网分析、路径规划和空间可视化。\n- **Pandas**（Python Data Analysis Library）是一个提供高性能、易于使用的数据结构和数据分析工具的Python库。它主要用于数据处理和数据分析，可以处理各种数据格式，如CSV文件、Excel表格、SQL数据库等，提供了丰富的数据操作和处理功能。\n- **NumPy**（Numerical Python）是Python中用于科学计算的一个核心库。它提供了多维数组对象（例如ndarray）、各种派生对象（例如masked arrays和matrices）、以及用于数组快速操作的各种函数。NumPy是许多其他科学计算库的基础，因为它提供了高效的数组操作和运算功能。\n- **Geopandas** 是在Pandas基础上扩展的地理空间数据处理库，提供了地理空间数据结构和方便的数据操作功能。它使得在 Python 中处理地理空间数据变得简单和高效，可以处理各种地理空间数据格式，如Shapefile、GeoJSON等，并提供了空间数据的分析和可视化功能。\n- **Shapely** 是一个 Python 库，用于处理几何对象，如点、线和多边形。它提供了创建、分析和操作这些对象的功能，可用于地理空间数据处理和分析。Shapely 简化了空间数据的操作，使得在Python中处理地理信息变得更加简单和高效。\n- **math** 是 Python 标准库中的一个模块，提供了许多数学函数和常量。\n\n#### 1.1.3 导入Python包\n```python\nimport osmnx as ox\nimport geopandas as gpd\nimport pandas as pd\nimport numpy as np\nimport geopandas as gpd\nfrom shapely import wkt\nfrom shapely.geometry import LineString\nimport math\n```\n### 1.2 路网的提取\n#### 1.2.1 根据城市名称获取路网\n```python\nplace_name = \"Chendu, China\"\ngraph = ox.graph_from_place(place_name, network_type='drive')\n```\nplace_name指定城市位置（格式为城市，国家），graph是根据位置获得的路网图，类型为多图。\n#### 1.2.2 根据经纬度边界获取路网\n```python\nnorth, south, east, west = 30.67, 30.65, 104.07, 104.05\ngraph = ox.graph_from_bbox(north, south, east, west, network_type='drive')\n```\nnorth, south, east, west指定经纬度的边界（四个参数亦可以使用bbox代替），graph是根据位置获得的路网图，类型为多图。\n#### 1.2.3 其他获取路网的方式\n其他获取路网的方式请参考：https://github.com/gboeing/osmnx\n### 1.3 路网的处理\n#### 1.3.1 提取节点与边\n```python\ngdf_nodes, gdf_edges = ox.graph_to_gdfs(graph)\n```\ngdf_nodes是点的集合，gdf_edges是边的集合，它们的类型都是GeoDataFrame，包含字段见下表：\n\n**gdf_nodes**：\n\n| 字段名        | 解释            | 数据类型 |\n|--------------|-----------------|---------|\n| y            | 纬度            | double   |\n| x            | 经度            | double   |\n| street_count | 包含点的路段数量 | int      |\n| highway      | 道路类型        | string   |\n| geometry     | 几何形状        | Point    |\n\n**gdf_edges**：\n\n| 字段名        | 解释             | 数据类型  |\n|--------------|----------------- |-----------|\n| u (index)    | 起点id           | double    |\n| v (index)    | 终点id           | double    |\n| key (index)  | 权重             | int       |\n| osmid        | 道路osmID        | List(long)|\n| oneway       | 是否单向         | boolean   |\n| highway      | 道路类型         | string    |\n| reversed     | 是否反转         | boolean   |\n| length       | 路段长度         | double    |\n| geometry     | 几何形状         | LineString |\n| lanes        | 车道数量         | int       |\n| ref          | 道路编码         | string    |\n| name         | 道路名称         | string    |\n| brigde       | 是否桥梁         | string(Yes/No/NaN) |\n| tunnel       | 是否隧道         | string(Yes/No/NaN) |\n| maxspeed     | 最大限速         | int       |\n| junction     | 路口类型         | string    |\n| access       | 使用权           | string    |\n| width        | 道路宽度         | double    |\n| landuse      | 土地利用         | string    |\n\n为提取路网，我们需要使用到gdf_edges中的u,v获取路段的起点与终点，通过oneway字段与reversed确定路段方向,通过length获取路段长度。\n\n#### 1.3.2 取消索引并生成唯一id\n```python\ngdf_edges.reset_index(inplace=True)\ngdf_edges['id']=np.arange(gdf_edges.shape[0])\n```\n#### 1.3.3 更具路网的字段确定需要处理的列\n假设路网的字段为：起点id，终点id，路段长度，路段方向（未定义-1，双向1，正向2，反向3），路段等级，路段限速。\n```python\n#添加需要处理的列\ngdf_edges['start_id'] = gdf_edges['u']\ngdf_edges['end_id'] = gdf_edges['v']\ngdf_edges['lengthInMeter'] = gdf_edges['length']\ngdf_edges['direction'] = -1\ngdf_edges['level'] = 1\ngdf_edges['speed_limit'] = gdf_edges['maxspeed']\n#根据条件设置 direction 列的值\ngdf_edges['direction'] = gdf_edges.apply(lambda row: 2 if row['oneway'] == True and row['reversed'] == False else (3 if row['oneway'] == True and row['reversed'] == True else 1), axis=1)\n#速度限制取最大值\ngdf_selected['speed_limit'] = gdf_selected['speed_limit'].apply(lambda x: x if isinstance(x, int) else max(x))\n```\n#### 1.3.4 成功新生成路段起点与终点id\n```python\n# 合并两列并找出所有唯一值\nunique_values = pd.concat([gdf_edges['start_id'], gdf_edges['end_id']]).unique()\n# 为每个唯一值生成编号，格式为 \"t_n\"\nvalue_to_id = {val: f\"t_{i+1}\" for i, val in enumerate(unique_values)}\n# 更新DataFrame中的列\ngdf_edges['start_id'] = gdf_edges['start_id'].map(value_to_id)\ngdf_edges['end_id'] = gdf_edges['end_id'].map(value_to_id)\n# 去除 't_' 前缀\ngdf_edges['start_id'] = gdf_edges['start_id'].str.replace('t_', '')\ngdf_edges['end_id'] = gdf_edges['end_id'].str.replace('t_', '')\n```\n#### 1.3.5 异常值的处理\n```python\n#空值的填充\ngdf_edges = gdf_edges.fillna(0)\n```\n#### 1.3.6 路网数据的存储\n```python\ngdf_selected = gdf_edges[['index', 'geometry', 'start_id', 'end_id', 'direction', 'level' , 'speed_limit','lengthInMeter']]\ngdf_selected.to_csv('outputchengdu.csv', sep='|', index=False)\n```\n其中分隔符设置为\"|\"，不存储索引。","slug":"使用Python提取城市路网","published":1,"updated":"2024-11-21T13:59:48.215Z","_id":"cm3rcvwhi0004usb0677uhn26","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"路网提取教程V1-0\"><a href=\"#路网提取教程V1-0\" class=\"headerlink\" title=\"路网提取教程V1.0\"></a>路网提取教程V1.0</h1><h2 id=\"一-基于Python的路网提取\"><a href=\"#一-基于Python的路网提取\" class=\"headerlink\" title=\"一.基于Python的路网提取\"></a>一.基于Python的路网提取</h2><h3 id=\"1-1-环境准备\"><a href=\"#1-1-环境准备\" class=\"headerlink\" title=\"1.1 环境准备\"></a>1.1 环境准备</h3><h4 id=\"1-1-1-Python的安装\"><a href=\"#1-1-1-Python的安装\" class=\"headerlink\" title=\"1.1.1 Python的安装\"></a>1.1.1 Python的安装</h4><p>Python下载：<a href=\"https://www.python.org/\">https://www.python.org/</a> （确保安装pip，如果希望环境分离可以安装conda：<a href=\"https://www.anaconda.com/download\">https://www.anaconda.com/download</a> ）<br>Pycharm下载：<a href=\"https://www.jetbrains.com/zh-cn/pycharm/\">https://www.jetbrains.com/zh-cn/pycharm/</a> (建议安装jupter插件进行交互式编写)</p>\n<h4 id=\"1-1-2-必要的Python包的安装\"><a href=\"#1-1-2-必要的Python包的安装\" class=\"headerlink\" title=\"1.1.2 必要的Python包的安装\"></a>1.1.2 必要的Python包的安装</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install osmnx geopandas pandas numpy shapely</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>osmnx</strong> 是一个基于 OpenStreetMap 数据的 Python 库，用于从 OpenStreetMap 获取、构建、分析和可视化街道网络和其他地理空间数据。通过 osmnx，我们可以轻松地检索全球范围内的街道网络数据，并进行各种空间分析，如路网分析、路径规划和空间可视化。</li>\n<li><strong>Pandas</strong>（Python Data Analysis Library）是一个提供高性能、易于使用的数据结构和数据分析工具的Python库。它主要用于数据处理和数据分析，可以处理各种数据格式，如CSV文件、Excel表格、SQL数据库等，提供了丰富的数据操作和处理功能。</li>\n<li><strong>NumPy</strong>（Numerical Python）是Python中用于科学计算的一个核心库。它提供了多维数组对象（例如ndarray）、各种派生对象（例如masked arrays和matrices）、以及用于数组快速操作的各种函数。NumPy是许多其他科学计算库的基础，因为它提供了高效的数组操作和运算功能。</li>\n<li><strong>Geopandas</strong> 是在Pandas基础上扩展的地理空间数据处理库，提供了地理空间数据结构和方便的数据操作功能。它使得在 Python 中处理地理空间数据变得简单和高效，可以处理各种地理空间数据格式，如Shapefile、GeoJSON等，并提供了空间数据的分析和可视化功能。</li>\n<li><strong>Shapely</strong> 是一个 Python 库，用于处理几何对象，如点、线和多边形。它提供了创建、分析和操作这些对象的功能，可用于地理空间数据处理和分析。Shapely 简化了空间数据的操作，使得在Python中处理地理信息变得更加简单和高效。</li>\n<li><strong>math</strong> 是 Python 标准库中的一个模块，提供了许多数学函数和常量。</li>\n</ul>\n<h4 id=\"1-1-3-导入Python包\"><a href=\"#1-1-3-导入Python包\" class=\"headerlink\" title=\"1.1.3 导入Python包\"></a>1.1.3 导入Python包</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> osmnx <span class=\"keyword\">as</span> ox</span><br><span class=\"line\"><span class=\"keyword\">import</span> geopandas <span class=\"keyword\">as</span> gpd</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> geopandas <span class=\"keyword\">as</span> gpd</span><br><span class=\"line\"><span class=\"keyword\">from</span> shapely <span class=\"keyword\">import</span> wkt</span><br><span class=\"line\"><span class=\"keyword\">from</span> shapely.geometry <span class=\"keyword\">import</span> LineString</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-路网的提取\"><a href=\"#1-2-路网的提取\" class=\"headerlink\" title=\"1.2 路网的提取\"></a>1.2 路网的提取</h3><h4 id=\"1-2-1-根据城市名称获取路网\"><a href=\"#1-2-1-根据城市名称获取路网\" class=\"headerlink\" title=\"1.2.1 根据城市名称获取路网\"></a>1.2.1 根据城市名称获取路网</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">place_name = <span class=\"string\">&quot;Chendu, China&quot;</span></span><br><span class=\"line\">graph = ox.graph_from_place(place_name, network_type=<span class=\"string\">&#x27;drive&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>place_name指定城市位置（格式为城市，国家），graph是根据位置获得的路网图，类型为多图。</p>\n<h4 id=\"1-2-2-根据经纬度边界获取路网\"><a href=\"#1-2-2-根据经纬度边界获取路网\" class=\"headerlink\" title=\"1.2.2 根据经纬度边界获取路网\"></a>1.2.2 根据经纬度边界获取路网</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">north, south, east, west = <span class=\"number\">30.67</span>, <span class=\"number\">30.65</span>, <span class=\"number\">104.07</span>, <span class=\"number\">104.05</span></span><br><span class=\"line\">graph = ox.graph_from_bbox(north, south, east, west, network_type=<span class=\"string\">&#x27;drive&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>north, south, east, west指定经纬度的边界（四个参数亦可以使用bbox代替），graph是根据位置获得的路网图，类型为多图。</p>\n<h4 id=\"1-2-3-其他获取路网的方式\"><a href=\"#1-2-3-其他获取路网的方式\" class=\"headerlink\" title=\"1.2.3 其他获取路网的方式\"></a>1.2.3 其他获取路网的方式</h4><p>其他获取路网的方式请参考：<a href=\"https://github.com/gboeing/osmnx\">https://github.com/gboeing/osmnx</a></p>\n<h3 id=\"1-3-路网的处理\"><a href=\"#1-3-路网的处理\" class=\"headerlink\" title=\"1.3 路网的处理\"></a>1.3 路网的处理</h3><h4 id=\"1-3-1-提取节点与边\"><a href=\"#1-3-1-提取节点与边\" class=\"headerlink\" title=\"1.3.1 提取节点与边\"></a>1.3.1 提取节点与边</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdf_nodes, gdf_edges = ox.graph_to_gdfs(graph)</span><br></pre></td></tr></table></figure>\n<p>gdf_nodes是点的集合，gdf_edges是边的集合，它们的类型都是GeoDataFrame，包含字段见下表：</p>\n<p><strong>gdf_nodes</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>解释</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>y</td>\n<td>纬度</td>\n<td>double</td>\n</tr>\n<tr>\n<td>x</td>\n<td>经度</td>\n<td>double</td>\n</tr>\n<tr>\n<td>street_count</td>\n<td>包含点的路段数量</td>\n<td>int</td>\n</tr>\n<tr>\n<td>highway</td>\n<td>道路类型</td>\n<td>string</td>\n</tr>\n<tr>\n<td>geometry</td>\n<td>几何形状</td>\n<td>Point</td>\n</tr>\n</tbody></table>\n<p><strong>gdf_edges</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>解释</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u (index)</td>\n<td>起点id</td>\n<td>double</td>\n</tr>\n<tr>\n<td>v (index)</td>\n<td>终点id</td>\n<td>double</td>\n</tr>\n<tr>\n<td>key (index)</td>\n<td>权重</td>\n<td>int</td>\n</tr>\n<tr>\n<td>osmid</td>\n<td>道路osmID</td>\n<td>List(long)</td>\n</tr>\n<tr>\n<td>oneway</td>\n<td>是否单向</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>highway</td>\n<td>道路类型</td>\n<td>string</td>\n</tr>\n<tr>\n<td>reversed</td>\n<td>是否反转</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>length</td>\n<td>路段长度</td>\n<td>double</td>\n</tr>\n<tr>\n<td>geometry</td>\n<td>几何形状</td>\n<td>LineString</td>\n</tr>\n<tr>\n<td>lanes</td>\n<td>车道数量</td>\n<td>int</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>道路编码</td>\n<td>string</td>\n</tr>\n<tr>\n<td>name</td>\n<td>道路名称</td>\n<td>string</td>\n</tr>\n<tr>\n<td>brigde</td>\n<td>是否桥梁</td>\n<td>string(Yes&#x2F;No&#x2F;NaN)</td>\n</tr>\n<tr>\n<td>tunnel</td>\n<td>是否隧道</td>\n<td>string(Yes&#x2F;No&#x2F;NaN)</td>\n</tr>\n<tr>\n<td>maxspeed</td>\n<td>最大限速</td>\n<td>int</td>\n</tr>\n<tr>\n<td>junction</td>\n<td>路口类型</td>\n<td>string</td>\n</tr>\n<tr>\n<td>access</td>\n<td>使用权</td>\n<td>string</td>\n</tr>\n<tr>\n<td>width</td>\n<td>道路宽度</td>\n<td>double</td>\n</tr>\n<tr>\n<td>landuse</td>\n<td>土地利用</td>\n<td>string</td>\n</tr>\n</tbody></table>\n<p>为提取路网，我们需要使用到gdf_edges中的u,v获取路段的起点与终点，通过oneway字段与reversed确定路段方向,通过length获取路段长度。</p>\n<h4 id=\"1-3-2-取消索引并生成唯一id\"><a href=\"#1-3-2-取消索引并生成唯一id\" class=\"headerlink\" title=\"1.3.2 取消索引并生成唯一id\"></a>1.3.2 取消索引并生成唯一id</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdf_edges.reset_index(inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;id&#x27;</span>]=np.arange(gdf_edges.shape[<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-3-更具路网的字段确定需要处理的列\"><a href=\"#1-3-3-更具路网的字段确定需要处理的列\" class=\"headerlink\" title=\"1.3.3 更具路网的字段确定需要处理的列\"></a>1.3.3 更具路网的字段确定需要处理的列</h4><p>假设路网的字段为：起点id，终点id，路段长度，路段方向（未定义-1，双向1，正向2，反向3），路段等级，路段限速。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#添加需要处理的列</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;u&#x27;</span>]</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;v&#x27;</span>]</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;lengthInMeter&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;length&#x27;</span>]</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;direction&#x27;</span>] = -<span class=\"number\">1</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;level&#x27;</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;speed_limit&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;maxspeed&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">#根据条件设置 direction 列的值</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;direction&#x27;</span>] = gdf_edges.apply(<span class=\"keyword\">lambda</span> row: <span class=\"number\">2</span> <span class=\"keyword\">if</span> row[<span class=\"string\">&#x27;oneway&#x27;</span>] == <span class=\"literal\">True</span> <span class=\"keyword\">and</span> row[<span class=\"string\">&#x27;reversed&#x27;</span>] == <span class=\"literal\">False</span> <span class=\"keyword\">else</span> (<span class=\"number\">3</span> <span class=\"keyword\">if</span> row[<span class=\"string\">&#x27;oneway&#x27;</span>] == <span class=\"literal\">True</span> <span class=\"keyword\">and</span> row[<span class=\"string\">&#x27;reversed&#x27;</span>] == <span class=\"literal\">True</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span>), axis=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">#速度限制取最大值</span></span><br><span class=\"line\">gdf_selected[<span class=\"string\">&#x27;speed_limit&#x27;</span>] = gdf_selected[<span class=\"string\">&#x27;speed_limit&#x27;</span>].apply(<span class=\"keyword\">lambda</span> x: x <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(x, <span class=\"built_in\">int</span>) <span class=\"keyword\">else</span> <span class=\"built_in\">max</span>(x))</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-4-成功新生成路段起点与终点id\"><a href=\"#1-3-4-成功新生成路段起点与终点id\" class=\"headerlink\" title=\"1.3.4 成功新生成路段起点与终点id\"></a>1.3.4 成功新生成路段起点与终点id</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 合并两列并找出所有唯一值</span></span><br><span class=\"line\">unique_values = pd.concat([gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>], gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>]]).unique()</span><br><span class=\"line\"><span class=\"comment\"># 为每个唯一值生成编号，格式为 &quot;t_n&quot;</span></span><br><span class=\"line\">value_to_id = &#123;val: <span class=\"string\">f&quot;t_<span class=\"subst\">&#123;i+<span class=\"number\">1</span>&#125;</span>&quot;</span> <span class=\"keyword\">for</span> i, val <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(unique_values)&#125;</span><br><span class=\"line\"><span class=\"comment\"># 更新DataFrame中的列</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>].<span class=\"built_in\">map</span>(value_to_id)</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>].<span class=\"built_in\">map</span>(value_to_id)</span><br><span class=\"line\"><span class=\"comment\"># 去除 &#x27;t_&#x27; 前缀</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>].<span class=\"built_in\">str</span>.replace(<span class=\"string\">&#x27;t_&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>].<span class=\"built_in\">str</span>.replace(<span class=\"string\">&#x27;t_&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-5-异常值的处理\"><a href=\"#1-3-5-异常值的处理\" class=\"headerlink\" title=\"1.3.5 异常值的处理\"></a>1.3.5 异常值的处理</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#空值的填充</span></span><br><span class=\"line\">gdf_edges = gdf_edges.fillna(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-6-路网数据的存储\"><a href=\"#1-3-6-路网数据的存储\" class=\"headerlink\" title=\"1.3.6 路网数据的存储\"></a>1.3.6 路网数据的存储</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdf_selected = gdf_edges[[<span class=\"string\">&#x27;index&#x27;</span>, <span class=\"string\">&#x27;geometry&#x27;</span>, <span class=\"string\">&#x27;start_id&#x27;</span>, <span class=\"string\">&#x27;end_id&#x27;</span>, <span class=\"string\">&#x27;direction&#x27;</span>, <span class=\"string\">&#x27;level&#x27;</span> , <span class=\"string\">&#x27;speed_limit&#x27;</span>,<span class=\"string\">&#x27;lengthInMeter&#x27;</span>]]</span><br><span class=\"line\">gdf_selected.to_csv(<span class=\"string\">&#x27;outputchengdu.csv&#x27;</span>, sep=<span class=\"string\">&#x27;|&#x27;</span>, index=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n<p>其中分隔符设置为”|”，不存储索引。</p>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"路网提取教程V1-0\"><a href=\"#路网提取教程V1-0\" class=\"headerlink\" title=\"路网提取教程V1.0\"></a>路网提取教程V1.0</h1><h2 id=\"一-基于Python的路网提取\"><a href=\"#一-基于Python的路网提取\" class=\"headerlink\" title=\"一.基于Python的路网提取\"></a>一.基于Python的路网提取</h2><h3 id=\"1-1-环境准备\"><a href=\"#1-1-环境准备\" class=\"headerlink\" title=\"1.1 环境准备\"></a>1.1 环境准备</h3><h4 id=\"1-1-1-Python的安装\"><a href=\"#1-1-1-Python的安装\" class=\"headerlink\" title=\"1.1.1 Python的安装\"></a>1.1.1 Python的安装</h4><p>Python下载：<a href=\"https://www.python.org/\">https://www.python.org/</a> （确保安装pip，如果希望环境分离可以安装conda：<a href=\"https://www.anaconda.com/download\">https://www.anaconda.com/download</a> ）<br>Pycharm下载：<a href=\"https://www.jetbrains.com/zh-cn/pycharm/\">https://www.jetbrains.com/zh-cn/pycharm/</a> (建议安装jupter插件进行交互式编写)</p>\n<h4 id=\"1-1-2-必要的Python包的安装\"><a href=\"#1-1-2-必要的Python包的安装\" class=\"headerlink\" title=\"1.1.2 必要的Python包的安装\"></a>1.1.2 必要的Python包的安装</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install osmnx geopandas pandas numpy shapely</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>osmnx</strong> 是一个基于 OpenStreetMap 数据的 Python 库，用于从 OpenStreetMap 获取、构建、分析和可视化街道网络和其他地理空间数据。通过 osmnx，我们可以轻松地检索全球范围内的街道网络数据，并进行各种空间分析，如路网分析、路径规划和空间可视化。</li>\n<li><strong>Pandas</strong>（Python Data Analysis Library）是一个提供高性能、易于使用的数据结构和数据分析工具的Python库。它主要用于数据处理和数据分析，可以处理各种数据格式，如CSV文件、Excel表格、SQL数据库等，提供了丰富的数据操作和处理功能。</li>\n<li><strong>NumPy</strong>（Numerical Python）是Python中用于科学计算的一个核心库。它提供了多维数组对象（例如ndarray）、各种派生对象（例如masked arrays和matrices）、以及用于数组快速操作的各种函数。NumPy是许多其他科学计算库的基础，因为它提供了高效的数组操作和运算功能。</li>\n<li><strong>Geopandas</strong> 是在Pandas基础上扩展的地理空间数据处理库，提供了地理空间数据结构和方便的数据操作功能。它使得在 Python 中处理地理空间数据变得简单和高效，可以处理各种地理空间数据格式，如Shapefile、GeoJSON等，并提供了空间数据的分析和可视化功能。</li>\n<li><strong>Shapely</strong> 是一个 Python 库，用于处理几何对象，如点、线和多边形。它提供了创建、分析和操作这些对象的功能，可用于地理空间数据处理和分析。Shapely 简化了空间数据的操作，使得在Python中处理地理信息变得更加简单和高效。</li>\n<li><strong>math</strong> 是 Python 标准库中的一个模块，提供了许多数学函数和常量。</li>\n</ul>\n<h4 id=\"1-1-3-导入Python包\"><a href=\"#1-1-3-导入Python包\" class=\"headerlink\" title=\"1.1.3 导入Python包\"></a>1.1.3 导入Python包</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> osmnx <span class=\"keyword\">as</span> ox</span><br><span class=\"line\"><span class=\"keyword\">import</span> geopandas <span class=\"keyword\">as</span> gpd</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> geopandas <span class=\"keyword\">as</span> gpd</span><br><span class=\"line\"><span class=\"keyword\">from</span> shapely <span class=\"keyword\">import</span> wkt</span><br><span class=\"line\"><span class=\"keyword\">from</span> shapely.geometry <span class=\"keyword\">import</span> LineString</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-路网的提取\"><a href=\"#1-2-路网的提取\" class=\"headerlink\" title=\"1.2 路网的提取\"></a>1.2 路网的提取</h3><h4 id=\"1-2-1-根据城市名称获取路网\"><a href=\"#1-2-1-根据城市名称获取路网\" class=\"headerlink\" title=\"1.2.1 根据城市名称获取路网\"></a>1.2.1 根据城市名称获取路网</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">place_name = <span class=\"string\">&quot;Chendu, China&quot;</span></span><br><span class=\"line\">graph = ox.graph_from_place(place_name, network_type=<span class=\"string\">&#x27;drive&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>place_name指定城市位置（格式为城市，国家），graph是根据位置获得的路网图，类型为多图。</p>\n<h4 id=\"1-2-2-根据经纬度边界获取路网\"><a href=\"#1-2-2-根据经纬度边界获取路网\" class=\"headerlink\" title=\"1.2.2 根据经纬度边界获取路网\"></a>1.2.2 根据经纬度边界获取路网</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">north, south, east, west = <span class=\"number\">30.67</span>, <span class=\"number\">30.65</span>, <span class=\"number\">104.07</span>, <span class=\"number\">104.05</span></span><br><span class=\"line\">graph = ox.graph_from_bbox(north, south, east, west, network_type=<span class=\"string\">&#x27;drive&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>north, south, east, west指定经纬度的边界（四个参数亦可以使用bbox代替），graph是根据位置获得的路网图，类型为多图。</p>\n<h4 id=\"1-2-3-其他获取路网的方式\"><a href=\"#1-2-3-其他获取路网的方式\" class=\"headerlink\" title=\"1.2.3 其他获取路网的方式\"></a>1.2.3 其他获取路网的方式</h4><p>其他获取路网的方式请参考：<a href=\"https://github.com/gboeing/osmnx\">https://github.com/gboeing/osmnx</a></p>\n<h3 id=\"1-3-路网的处理\"><a href=\"#1-3-路网的处理\" class=\"headerlink\" title=\"1.3 路网的处理\"></a>1.3 路网的处理</h3><h4 id=\"1-3-1-提取节点与边\"><a href=\"#1-3-1-提取节点与边\" class=\"headerlink\" title=\"1.3.1 提取节点与边\"></a>1.3.1 提取节点与边</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdf_nodes, gdf_edges = ox.graph_to_gdfs(graph)</span><br></pre></td></tr></table></figure>\n<p>gdf_nodes是点的集合，gdf_edges是边的集合，它们的类型都是GeoDataFrame，包含字段见下表：</p>\n<p><strong>gdf_nodes</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>解释</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>y</td>\n<td>纬度</td>\n<td>double</td>\n</tr>\n<tr>\n<td>x</td>\n<td>经度</td>\n<td>double</td>\n</tr>\n<tr>\n<td>street_count</td>\n<td>包含点的路段数量</td>\n<td>int</td>\n</tr>\n<tr>\n<td>highway</td>\n<td>道路类型</td>\n<td>string</td>\n</tr>\n<tr>\n<td>geometry</td>\n<td>几何形状</td>\n<td>Point</td>\n</tr>\n</tbody></table>\n<p><strong>gdf_edges</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>解释</th>\n<th>数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u (index)</td>\n<td>起点id</td>\n<td>double</td>\n</tr>\n<tr>\n<td>v (index)</td>\n<td>终点id</td>\n<td>double</td>\n</tr>\n<tr>\n<td>key (index)</td>\n<td>权重</td>\n<td>int</td>\n</tr>\n<tr>\n<td>osmid</td>\n<td>道路osmID</td>\n<td>List(long)</td>\n</tr>\n<tr>\n<td>oneway</td>\n<td>是否单向</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>highway</td>\n<td>道路类型</td>\n<td>string</td>\n</tr>\n<tr>\n<td>reversed</td>\n<td>是否反转</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>length</td>\n<td>路段长度</td>\n<td>double</td>\n</tr>\n<tr>\n<td>geometry</td>\n<td>几何形状</td>\n<td>LineString</td>\n</tr>\n<tr>\n<td>lanes</td>\n<td>车道数量</td>\n<td>int</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>道路编码</td>\n<td>string</td>\n</tr>\n<tr>\n<td>name</td>\n<td>道路名称</td>\n<td>string</td>\n</tr>\n<tr>\n<td>brigde</td>\n<td>是否桥梁</td>\n<td>string(Yes&#x2F;No&#x2F;NaN)</td>\n</tr>\n<tr>\n<td>tunnel</td>\n<td>是否隧道</td>\n<td>string(Yes&#x2F;No&#x2F;NaN)</td>\n</tr>\n<tr>\n<td>maxspeed</td>\n<td>最大限速</td>\n<td>int</td>\n</tr>\n<tr>\n<td>junction</td>\n<td>路口类型</td>\n<td>string</td>\n</tr>\n<tr>\n<td>access</td>\n<td>使用权</td>\n<td>string</td>\n</tr>\n<tr>\n<td>width</td>\n<td>道路宽度</td>\n<td>double</td>\n</tr>\n<tr>\n<td>landuse</td>\n<td>土地利用</td>\n<td>string</td>\n</tr>\n</tbody></table>\n<p>为提取路网，我们需要使用到gdf_edges中的u,v获取路段的起点与终点，通过oneway字段与reversed确定路段方向,通过length获取路段长度。</p>\n<h4 id=\"1-3-2-取消索引并生成唯一id\"><a href=\"#1-3-2-取消索引并生成唯一id\" class=\"headerlink\" title=\"1.3.2 取消索引并生成唯一id\"></a>1.3.2 取消索引并生成唯一id</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdf_edges.reset_index(inplace=<span class=\"literal\">True</span>)</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;id&#x27;</span>]=np.arange(gdf_edges.shape[<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-3-更具路网的字段确定需要处理的列\"><a href=\"#1-3-3-更具路网的字段确定需要处理的列\" class=\"headerlink\" title=\"1.3.3 更具路网的字段确定需要处理的列\"></a>1.3.3 更具路网的字段确定需要处理的列</h4><p>假设路网的字段为：起点id，终点id，路段长度，路段方向（未定义-1，双向1，正向2，反向3），路段等级，路段限速。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#添加需要处理的列</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;u&#x27;</span>]</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;v&#x27;</span>]</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;lengthInMeter&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;length&#x27;</span>]</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;direction&#x27;</span>] = -<span class=\"number\">1</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;level&#x27;</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;speed_limit&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;maxspeed&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">#根据条件设置 direction 列的值</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;direction&#x27;</span>] = gdf_edges.apply(<span class=\"keyword\">lambda</span> row: <span class=\"number\">2</span> <span class=\"keyword\">if</span> row[<span class=\"string\">&#x27;oneway&#x27;</span>] == <span class=\"literal\">True</span> <span class=\"keyword\">and</span> row[<span class=\"string\">&#x27;reversed&#x27;</span>] == <span class=\"literal\">False</span> <span class=\"keyword\">else</span> (<span class=\"number\">3</span> <span class=\"keyword\">if</span> row[<span class=\"string\">&#x27;oneway&#x27;</span>] == <span class=\"literal\">True</span> <span class=\"keyword\">and</span> row[<span class=\"string\">&#x27;reversed&#x27;</span>] == <span class=\"literal\">True</span> <span class=\"keyword\">else</span> <span class=\"number\">1</span>), axis=<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">#速度限制取最大值</span></span><br><span class=\"line\">gdf_selected[<span class=\"string\">&#x27;speed_limit&#x27;</span>] = gdf_selected[<span class=\"string\">&#x27;speed_limit&#x27;</span>].apply(<span class=\"keyword\">lambda</span> x: x <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(x, <span class=\"built_in\">int</span>) <span class=\"keyword\">else</span> <span class=\"built_in\">max</span>(x))</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-4-成功新生成路段起点与终点id\"><a href=\"#1-3-4-成功新生成路段起点与终点id\" class=\"headerlink\" title=\"1.3.4 成功新生成路段起点与终点id\"></a>1.3.4 成功新生成路段起点与终点id</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 合并两列并找出所有唯一值</span></span><br><span class=\"line\">unique_values = pd.concat([gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>], gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>]]).unique()</span><br><span class=\"line\"><span class=\"comment\"># 为每个唯一值生成编号，格式为 &quot;t_n&quot;</span></span><br><span class=\"line\">value_to_id = &#123;val: <span class=\"string\">f&quot;t_<span class=\"subst\">&#123;i+<span class=\"number\">1</span>&#125;</span>&quot;</span> <span class=\"keyword\">for</span> i, val <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(unique_values)&#125;</span><br><span class=\"line\"><span class=\"comment\"># 更新DataFrame中的列</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>].<span class=\"built_in\">map</span>(value_to_id)</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>].<span class=\"built_in\">map</span>(value_to_id)</span><br><span class=\"line\"><span class=\"comment\"># 去除 &#x27;t_&#x27; 前缀</span></span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;start_id&#x27;</span>].<span class=\"built_in\">str</span>.replace(<span class=\"string\">&#x27;t_&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>] = gdf_edges[<span class=\"string\">&#x27;end_id&#x27;</span>].<span class=\"built_in\">str</span>.replace(<span class=\"string\">&#x27;t_&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-5-异常值的处理\"><a href=\"#1-3-5-异常值的处理\" class=\"headerlink\" title=\"1.3.5 异常值的处理\"></a>1.3.5 异常值的处理</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#空值的填充</span></span><br><span class=\"line\">gdf_edges = gdf_edges.fillna(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-6-路网数据的存储\"><a href=\"#1-3-6-路网数据的存储\" class=\"headerlink\" title=\"1.3.6 路网数据的存储\"></a>1.3.6 路网数据的存储</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdf_selected = gdf_edges[[<span class=\"string\">&#x27;index&#x27;</span>, <span class=\"string\">&#x27;geometry&#x27;</span>, <span class=\"string\">&#x27;start_id&#x27;</span>, <span class=\"string\">&#x27;end_id&#x27;</span>, <span class=\"string\">&#x27;direction&#x27;</span>, <span class=\"string\">&#x27;level&#x27;</span> , <span class=\"string\">&#x27;speed_limit&#x27;</span>,<span class=\"string\">&#x27;lengthInMeter&#x27;</span>]]</span><br><span class=\"line\">gdf_selected.to_csv(<span class=\"string\">&#x27;outputchengdu.csv&#x27;</span>, sep=<span class=\"string\">&#x27;|&#x27;</span>, index=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n<p>其中分隔符设置为”|”，不存储索引。</p>\n"},{"title":"Parquet原理详解","date":"2024-11-18T02:26:54.000Z","cover":"/images/cover_image/parquet.jpg","_content":"\nApache Parquet 是一种高效的列式存储格式，其设计初衷是优化大规模数据处理的性能与存储效率。在大数据领域，随着数据规模的迅速增长，如何高效地存储、读取和处理数据已成为关键问题。作为 Apache 软件基金会支持的开源项目，Parquet 凭借卓越的数据压缩率和快速查询能力，被广泛应用于各类大数据处理场景。本文旨在从理论与实践的双重视角，系统分析 Apache Parquet 的设计理念、核心架构与技术实现，特别是其在处理复杂嵌套数据结构方面的独特优势，期望为研究者和开发者提供深入的理解与指导。\n\n---\n\n# 1. 基础概念\n\n## 1.1 列式存储 VS 行式存储\n\n**行式存储**：行式存储是将一行数据的所有字段连续存储在一起。例如，对于下表中的数据：\n\n| id | latitude   | longitude | timestamp  |\n| -- | ---------- | --------- | ---------- |\n| 23 | 106.551556 | 29.563761 | 1732118400 |\n| 46 | 106.480989 | 29.600298 | 1732161600 |\n| 99 | 106.512051 | 29.583541 | 1732183200 |\n\n在行式存储中，数据会按照以下方式存储：\n\n```\n23, 106.551556, 29.563761, 1732118400\n46, 106.480989, 29.600298, 1732161600\n99, 106.512051, 29.583541, 1732183200\n```\n\n每一行的数据被紧密地存储在一起，这样的存储方式便于对单行数据的增、删、改、查操作。 在行式存储模式下，整行数据的存取非常高效，尤其是在需要获取或修改完整的一行数据时，能够显著提高访问效率。行式存储的优点：\n1. **快速定位整行数据**：行式存储能够快速定位到某一行的数据。例如，当查询id=46的数据时，只需从存储中直接读取这一行，所有字段都能一次性高效返回。\n2. **事务操作支持好**：行式存储非常适合高频的增删改操作，例如修改id=23这一行的timestamp值。这种操作只需要定位到该行并进行更新，整体效率非常高。\n\n如果需要查询或更新id=46的所有数据，行式存储可以快速定位到46, 106.480989, 29.600298, 1732161600` 这一整行数据，并进行操作，而无需访问其他数据，因而效率非常高。行式存储特别适合 OLTP（在线事务处理）场景，电商系统、银行系统等需要频繁处理单条记录的增删改操作的应用中，行式存储表现尤为出色。\n\n\n**列式存储**：与行式存储不同，列式存储将同一列的数据连续存储在一起。对于上面的示例表格，列式存储方式如下：\n\n```\nid:        23, 46, 99\nlatitude:  106.551556, 106.480989, 106.512051\nlongitude: 29.563761, 29.600298, 29.583541\ntimestamp: 1732118400, 1732161600, 1732183200\n```\n\n在这种存储模式下，每列的数据在物理存储中是连续存放的，列与列之间的数据相互独立。列式存储更适合对某些列进行查询，例如在大数据分析中仅需要查询latitude和longitude，而无需加载其他字段。列式存储的优点：\n1. **按列查询性能高**：在数据分析场景中，查询操作往往只涉及少数列，例如筛选latitude接近106.5的数据。在列式存储中，只需读取 latitude列即可，这显著减少了 I/O 操作和内存占用，提高了查询效率。\n2. **压缩效果好**：由于同一列的数据类型相同且分布相似，列式存储能够实现高效压缩。例如，timestamp列的值有一定规律性，这样的数据在列式存储中可以被压缩得非常紧凑，从而节省存储空间并加速处理。\n\n如果需要查找所有记录的latitude，列式存储只需要读取106.551556, 106.480989, 106.512051这一列的数据，跳过其他列的数据，减少了读取不必要数据的开销，这对于大规模数据分析非常高效。 列式存储非常适合OLAP（在线分析处理）场景，尤其在数据仓库、大规模数据分析等需要对大量数据进行聚合、过滤和统计计算的应用中，列式存储能够显著提高查询效率。\n\n# 2. Parquet详解\n\n## 2.1 数据模型\nParquet采用了一个类似Google Protobuf的协议来描述存储数据的schema，以下面这个schema为例介绍Parquet的数据模型。\n```\nmessage SpatialTemporalData {\n  required int32 id;\n  repeated double speeds;\n  repeated group trajectory {\n    required timestamp timestamp;\n    optional group location {\n      required double latitude;  \n      required double longitude; \n    }\n  }\n}\n```\n在这个schema中，每条记录代表一条轨迹。每条记录中有且仅有一个id，每个id可以对应0个或多个speeds和trajectory。每个trajectory必须包含一个timestamp，location字段则为可选字段。每个location必须包含唯一的latitude和longitude。在 schema的顶层是message，它可以包含多个字段。每个字段具有三个属性：**重复性**（repetition）、**类型**（type）和 **名字**（name）。\n\n字段的重复性包含三种：\n* required：有且只有一次\n* optional：0次或1次\n* repeated：0次或多次\n\n字段的类型包括：\n* 基础数据类型（物理上只存储基础数据类型）：BOOLEAN、INT32、INT64、INT96、FLOAT、DOUBLE、BYTE_ARRAY、FIXED_LEN_BYTE_ARRAY\n* 逻辑数据类型（指导如何转换成基础数据类型进行存储）：\n  * 字符串类型：STRING、ENUM、UUID\n  * 数字类型：有符号整数，无符号整数 INT(8/16/32/64, true/false)\n  * 十进制：DECIMAL\n  * 时间类型：DATE、TIME、TIMESTAMP\n  * 嵌入类型：JSON、BSON、VARIANT\n  * 嵌套类型：LIST（需要三级嵌套），MAP(需要三级嵌套)\n  * 空值\n\nLIST可以用repeated field来表示：\n```\nrepeated double speeds;\n=========================================================>(parquet格式)\noptional group field_id=-1 speeds (List) {\n    repeated group field_id=-1 list {\n      optional double field_id=-1 element;\n    }\n  }\n```\nMap可以用包含key-value对且key是required的repeated group来表示：\n```\nrepeated group trajectory {\n    required timestamp timestamp;\n    optional group location {\n      required double latitude;  \n      required double longitude; \n    }\n  }\n=========================================================>(parquet格式)\noptional group field_id=-1 trajectory (Map) {\n    repeated group field_id=-1 key_value {\n      required int64 field_id=-1 key (Timestamp);\n      optional group field_id=-1 value {\n        optional double field_id=-1 latitude;\n        optional double field_id=-1 longitude;\n      }\n    }\n  }\n```\n\n## 2.2 列式存储格式\n在Parquet格式的存储中，一个schema的树结构有几个叶子节点（叶子节点都是基础数据类型），实际的存储中就会有多少column。 上面SpatialTemporalData的schema的树结构如图所示：\n\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/schema.png\" style=\"width:66%;\"/>\n</div>\n\n这个schema实际存储5列，如表所示:\n\n| Column    | Type      | \n|-----------|-----------| \n| id        | INT32     | \n| speeds    | DOUBLE    | \n| timestamp | TIMESTAMP | \n| latitude  | DOUBLE    | \n| longitude | DOUBLE    | \n\n## 2.3 Repetition and Definition Levels\nParquet文件采用按列存储的方式，但面对复杂的嵌套结构时，由于嵌套和重复的位置难以确定，恢复原始嵌套结构变得具有一定挑战性。为了解决这一问题，Parquet使用了 **striping and assembly** 算法，通过为每条数据增加 **Repetition Levels** 和 **Definition Levels**，实现对嵌套结构的精准还原。得益于这种设计，任意字段的恢复无需依赖其他字段，同时还支持按照原始嵌套格式对任意字段子集进行重建，大大提升了数据解析的灵活性与效率。以下面表格中的数据为例：\n\n| **id** | **speeds**         | **trajectory.timestamp** | **trajectory.latitude** | **trajectory.longitude** |\n|--------|--------------------|--------------------------|-------------------------|--------------------------|\n| 1      | [12.5, 13.2, 14.1] | 2024-11-21 10:00:00      | 40.7128                 | -74.0060                 |\n|        |                    | 2024-11-21 10:05:00      | NULL                    | NULL                     |\n| 2      | [20.1, 21.3]       | 2024-11-21 11:00:00      | 34.0522                 | -118.2437                |\n\n### 2.3.1 Repetition Levels\n**Repetition Level** 用于表示当前值在路径中的重复层级，即该值位于哪个重复字段的结构中。 Repetition Level 专门用来处理重复字段。以 speeds 和 trajectory 为例：\n1. **speeds 字段**  \n   speeds 是一个列表类型字段，包含值 [12.5, 13.2, 14.1]。每个值的 Repetition Level 分别为 0、1 和 1：\n   - 12.5 是列表的第一个值（即列表的起点），因此它的 Repetition Level 为 0。\n   - 后续的值 13.2 和 14.1 都属于同一个列表，表示列表的后续元素，因此它们的 Repetition Level 为 1。\n\n2. **trajectory 字段**  \n   trajectory 是一个 Map 类型，其键为时间戳，值为包含经纬度的结构体。对于每个 Map 键值对：\n   - 第一个键值对（时间戳为 2024-11-21 10:00:00）：这是 Map 的第一个值，因此 Repetition Level 为 0。\n   - 第二个键值对（时间戳为 2024-11-21 10:05:00）：这是同一个 Map 中的第二个值，因此它的 Repetition Level 为 1，表示 Map 的重复部分。虽然纬度和经度的值为空，这些字段的 Repetition Level 依然为 1。\n   - 空值的状态不会影响 Repetition Level，而是通过 Definition Level 来表示。\n\n### 2.3.2 Definition Levels\n**Definition Level** 表示路径上有多少可选字段被定义。嵌套数据类型的一个特点是，某些字段（例如可选字段或重复字段）可以为空，或者未被定义。如果一个字段被定义了，那么它的所有父节点也都必须是已定义的。从根节点开始遍历，当某个字段的路径上某个节点为空时，我们记录当前的深度作为该字段的 Definition Level。如果某字段的 Definition Level 达到了它的最大值，就说明该字段是有数据的。对于必须字段（如 required 类型），字段始终是定义的，因此 Definition Level 不需要特别标明。而对于可选字段（如 optional 类型），Definition Level 用于区分字段是未定义（为空）还是有值。在关系型数据中，Definition Level 为 0 表示字段未定义，1 或更高表示字段已定义并可能有值。\n\n1. **在 speeds 字段中**：\n   - speeds 是一个列表字段，其元素是可选的。当列表中某个元素有值时，例如 12.5，它的 Definition Level 为 1，表示该元素被定义且有数据。\n   - 如果 speeds 列表为空，Definition Level 为 0，表示 speeds 未被定义。\n2. **在 trajectory 字段中**：\n   - trajectory 是一个 Map 类型字段，键为时间戳，值为嵌套的纬度和经度字段。\n   - 当时间戳键值对中，纬度和经度都有值时，例如 latitude = 40.7128 和 longitude = -74.0060，Definition Level 为 2，表示字段完全定义且有值。\n   - 如果某个时间戳的纬度和经度值为空（例如 timestamp 为 2024-11-21 10:05:00 的键值对），Definition Level 会降为 1，表示字段已定义但没有数据。\n   - 如果整个 trajectory 字段为空，Definition Level 为 0，表示字段未被定义。\n\n### 2.3.3 计算过程\n以下是第一条和第二条数据的 Repetition Level (R) 和 Definition Level (D) 的计算过程整合：\n\n对于第一条数据：\n- **id** 是标量字段，没有嵌套或重复，Repetition Level (R) 固定为 0，Definition Level (D) 固定为 0，表示字段始终定义并有值。\n- **speeds** 是一个列表，第一个元素 12.5 表示列表的起点，因此 R=0，D=1；后续的 13.2 和 14.1 属于同一列表，因此 R=1，D=1，表明字段存在且有值。\n- **trajectory.timestamp** 是Map的键，第一个键值对2024-11-21 10:00:00是 Map 的起点，R=0，D=2，表明键和值都定义且非空；第二个键值对2024-11-21 10:05:00是 Map 中的后续键值对，R=1，D=1，表明键已定义但值为空。\n- **trajectory.latitude** 和 **trajectory.longitude** 是 Map 值中的嵌套字段，2024-11-21 10:00:00对应的纬度和经度都存在（由于是required字段，与上一层保持相同），因此 R=0，D=2；2024-11-21 10:05:00的纬度和经度为空，R=1，D=1，表示字段已定义但无值。\n\n对于第二条数据：\n- **id** 是标量字段，与第一条类似，Repetition Level (R) 固定为0，Definition Level (D) 固定为0。\n- **speeds** 是一个列表，第一个元素 20.1 表示列表的起点，因此 R=0，D=1；后续的 21.3 属于同一列表，因此 R=1，D=1，表明字段存在且有值。\n- **trajectory.timestamp** 是Map的键，只有一个键值对2024-11-21 11:00:00，因此 R=0，D=2，表明键和值都定义且非空。\n- **trajectory.latitude** 和 **trajectory.longitude** 是 Map 值中的嵌套字段，2024-11-21 11:00:00对应的纬度和经度都存在，因此 R=0，D=2，表示字段已定义且有值。\n\n| **Column** | **Value** | **R** | **D** | **Column**               | **Value**           | **R** | **D** |\n|------------|-----------|-------|-------|--------------------------|---------------------|-------|-------|\n| **id**     | 1         | 0     | 0     | **trajectory.timestamp** | 2024-11-21 10:00:00 | 0     | 2     |\n|            | 2         | 0     | 0     |                          | 2024-11-21 10:05:00 | 1     | 1     |\n| **speeds** | 12.5      | 0     | 1     |                          | 2024-11-21 11:00:00 | 0     | 2     |\n|            | 13.2      | 1     | 1     | **trajectory.latitude**  | 40.7128             | 0     | 2     |\n|            | 14.1      | 1     | 1     |                          | NULL                | 1     | 1     |\n|            | 20.1      | 0     | 1     |                          | 34.0522             | 0     | 2     |\n|            | 21.3      | 1     | 1     | **trajectory.longitude** | -74.0060            | 0     | 2     |\n|            |           |       |       |                          | NULL                | 1     | 1     |\n|            |           |       |       |                          | -118.2437           | 0     | 2     |\n\n### 2.3.4 存储分析\n在Parquet中，所有字段会被展平为单独的列，每列存储其实际数据，同时附加R和D两列来记录层级结构和字段状态。Parquet并不存储NULL值，而是通过D的值来判断字段是否被定义。例如，Definition Level小于最大值时表示字段为空(NULL)。对于嵌套字段和重复字段（如MAP和LIST），R的值则用于区分新记录与同一结构中的后续值。\n\n这种设计的优点在于，它可以在保持数据层级关系的同时，避免存储冗余的层级结构信息。同时，由于R和D只需要几位就可以表示字段的状态（如7层结构只需要3bit + 3bit 就能表示R和D），存储开销极小。空字段无需存储实际值，仅通过R和D即可高效表示。这种机制使得Parquet格式在处理嵌套数据时既保持了灵活性，又显著提升了存储和读取效率。\n\n## 2.4 编码与压缩技术\n\n### 2.4.1 编码\n编码是将数据转换为更紧凑的格式，以减少存储空间或提高计算效率。Parquet 使用了几种常见的编码方式来对数据进行编码，这些编码方式有助于在存储时减少数据的冗余，提高读取性能。\n\n1. **PLAIN编码**：PLAIN编码是Parquet中最基础的编码方式，它将原始数据直接存储，没有进行任何压缩或变换。该编码方式简单且高效，适用于数据分布均匀的场景，但可能会占用较多存储空间。PLAIN 编码通常用于存储不需要特别优化的字段数据，如简单的整数或字符串。\n2. **DICTIONARY编码**：DICTIONARY编码是一种通过使用字典（映射表）将数据中的重复值替换为字典索引的编码方式。该编码方法适用于有大量重复值的数据类型，比如类别型数据。在Parquet中，数据被分成多个区块，每个区块都会为该区块内的数据生成一个字典。存储时，数据中的重复项会被替换为字典的索引，进而节省存储空间。例如，如果一个字段中有多个相同的值，那么这些值将被映射为字典的索引，存储时只需保存索引而不是重复的值。这种方法能够显著降低存储空间，但需要为每个数据块生成字典，可能会增加读取时的解码开销。\n3. **RLE（Run-Length Encoding）编码**：RLE（Run-Length Encoding）编码是通过记录连续相同值的数量来压缩数据的一种方式。在数据中，若出现连续相同的值，RLE 会记录这些值出现的次数，从而将重复的数据压缩成更小的表示形式。RLE 编码特别适用于数据中存在大量连续相同值的情况。例如，如果一个字段连续出现 100 个相同的数字，那么 RLE 会将其压缩为“值+出现次数”的形式。在 Parquet 中，RLE 编码常用于布尔类型数据或者重复出现的数字类型数据。\n4. **位打包（Bit-Packing）编码**：位打包（Bit-Packing）是一种将多个小数据类型压缩为更小比特数表示的编码方式。该方法通过打包多个值来提高存储效率，通常用于存储较小的数据类型，如整数、布尔值等。Bit-Packing 可以将每个字段中的数据值压缩为最小的比特位数，从而减少存储空间。\n5. **DELTA 编码**：DELTA编码是一种记录数据与其前一个值差异的编码方式。这种方法非常适合存储数值范围比较小且增减变化不大的数据。例如，对于一个增长规律较为平稳的数字序列，DELTA 编码将存储每个数值与前一个数值的差异，而不是存储完整的数值。这样可以显著降低存储空间，特别是对于时间序列数据或连续数据。\n\n### 2.4.2 编码压缩技术\n压缩是将数据进一步减少存储空间的技术。Parquet支持多种压缩算法，可以在不牺牲数据质量的情况下，进一步压缩数据以节省存储空间。常见的压缩算法包括Snappy、GZIP、LZO、Brotli等。\n1. Snappy压缩：Snappy 是 Google 开发的一种压缩算法，具有非常快的压缩和解压缩速度。它的压缩比虽然不如 GZIP，但由于其高效的速度，特别适合大数据处理场景中实时数据处理的需求。Snappy 通常是 Parquet 默认的压缩算法，尤其适用于对速度要求较高的场景。\n2. GZIP压缩：GZIP是一种较为常见的压缩算法，相较于Snappy，它的压缩比更高，但速度较慢。GZIP压缩适用于对存储空间有较高要求的场景，尤其是当存储成本较高或数据量特别大的时候。GZIP的高压缩比使得它能有效减少存储需求，但解压缩的速度可能成为瓶颈。\n3. LZO压缩：LZO是一种快速的压缩算法，类似于Snappy，适用于需要快速压缩和解压缩的场景。LZO的压缩比一般不如GZIP，但它的速度非常快，适合于大数据分析中对压缩速度要求较高的应用场景。\n4. Brotli压缩：Brotli 是由Google开发的一种压缩算法，常用于Web数据传输中的压缩。Brotli的压缩比比GZIP更高，并且其解压速度也较为高效。近年来，Brotli也开始在Parquet中被使用，尤其适用于对存储需求有较高要求的场景。\n5. Zstandard（ZSTD）压缩：Zstandard（ZSTD）是一种新兴的压缩算法，旨在提供比 GZIP 更高的压缩比和更快的解压速度。ZSTD 兼具了较高的压缩效率和较低的延迟，非常适合需要平衡存储与速度的应用场景。\n\n# 3. Parquet具体实现\n\n## 3.1 Parquet 文件存储格式中的术语\n\n在理解 Parquet 文件的存储结构时，熟悉其中关键术语至关重要。以下是 Parquet 中一些核心术语的定义：\n\n- **Block (HDFS 块)**：这是 Hadoop 分布式文件系统（HDFS）中数据存储的基本单元，Parquet 文件完全兼容 HDFS 的设计。Block 的大小在 Hadoop 1.x 版本中默认为 64MB，而在 Hadoop 2.x 版本中则增加至 128MB。HDFS 使用 Block 的副本机制来确保数据的冗余和容错能力，从而提高了系统的可靠性和稳定性。\n\n- **File (文件)**：这是存储在 HDFS 上的一个逻辑实体，包含文件的元数据信息，但其实际数据内容由多个 HDFS Block 保存。\n\n- **Row Group (行组)**：Parquet 将数据按行划分为多个逻辑上的水平分区。每个 Row Group 包含该组中所有列的列块（Column Chunk），是并行化和 IO 操作的基本单元。这样设计使得每个行组都可以独立解码，便于分布式处理。\n\n- **Column Chunk (列块)**：指单列数据在一个行组中的物理存储。列块在行组中是逻辑连续的，这种设计允许对列进行有效的压缩和编码，从而提高了存储的利用率。\n\n- **Page (页面)**：列块被进一步划分为多个 Page，这是 Parquet 文件压缩和编码的最小基本单元。每个列块中可能包含多个类型的 Page，例如数据页面、字典页面等。\n\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/format.png\" style=\"width:66%;\"/>\n</div>\n\n## 3.2 并行化执行的基本单元\n\n在 Parquet 文件中，不同层级的数据单元在并行化处理和 IO 操作中发挥不同的作用：\n\n- **MapReduce 任务划分**：在使用 Hadoop 的 MapReduce 框架处理数据时，通常以 File 或 Row Group 为基本单位来分配任务，即每个任务处理一个完整的文件或者一个行组，从而实现并行化。\n\n- **IO 操作**：Parquet 文件的 IO 操作以 Column Chunk 为基本单位进行。这种设计方式使得可以只读取所需列的数据，减少不必要的磁盘 IO，从而提高读取效率。\n\n- **编码和压缩**：在 Parquet 中，编码和压缩通常以 Page 为单位进行。每个页面可以使用不同的编码方法来提高压缩率，例如使用 RLE（Run Length Encoding）对重复值进行压缩，从而降低存储空间。\n\n## 3.3 Parquet 文件格式\n\nParquet 文件格式具有自解析的特性，文件使用 Thrift 格式定义 schema 以及其他元数据信息。这些元数据信息存储在文件末尾，方便读取时直接访问。\n\n典型的 Parquet 文件结构如下：\n\n- 整个文件被划分为多个行组，每个行组包含所有列的数据块和元数据信息。\n- 文件的元数据存储在数据部分的最后，包含了所有列块元数据的起始位置。\n\n这种将元数据存储在文件末尾的设计，使得在写入数据时可以顺序高效地写入文件，同时在读取文件时可以快速获取元数据并定位到相关数据块。\n\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/metadata.png\" style=\"width:66%;\"/>\n</div>\n\n## 3.4 元数据信息\n\nParquet 文件包含三种不同类型的元数据，每种元数据在不同层级描述文件的内容和结构：\n\n- **文件元数据**：描述整个文件的结构和内容，例如行组和列块的位置信息等，是文件级别的数据概览。\n- **列（块）元数据**：描述单个列块的详细信息，包括该列块的属性、位置和大小。这些元数据使得读取特定列块变得更加高效。\n- **页面头部元数据**：描述每个页面的具体属性，包括编码方式、压缩方法、页面位置等。这些元数据对于解码和读取页面中的数据至关重要。\n\n## 3.5 并行读取与列存储的优化\n\nParquet 的设计充分考虑了并行处理和列存储的优势。由于数据是按列存储的，因此可以非常高效地进行列的读取操作。尤其是对于只需要部分列的查询，Parquet 能够显著减少 IO 开销，提升性能。每个行组中的列块在物理上保持连续存储，这样即使是大规模并行读取也可以最大程度减少磁盘寻道时间。\n\n## 3.6 编码（Encoding）\n\nParquet 支持多种编码方式，以优化数据的压缩和读取效率。细节可以参考官方文档：[Parquet Encodings](https://github.com/apache/parquet-format/blob/master/Encodings.md)。通过采用不同的编码方法，Parquet 能够大幅度减少重复值存储，从而节省磁盘空间。\n\n## 3.7 Column Chunks 存储与读取\n\n每个 Column Chunk 是由多个 Page 组成的。在读取数据时，Parquet Reader 可以利用页面头部元数据中存储的信息，直接跳过不感兴趣的页面。例如，字典页面与数据页面存储的内容类型不同，Reader 可以根据需求决定是否需要加载某些页面，从而优化查询性能。\n\n## 3.8 错误处理机制\n\nParquet 文件设计了一系列机制来应对数据损坏的情况，以保证数据的可用性和可靠性：\n\n- **文件元数据损坏**：如果整个文件的元数据损坏，通常情况下整个文件会无法读取。\n- **列元数据损坏**：如果某个列的元数据损坏，只会影响该列块的读取，其他行组中相同列的块仍可正常使用，这种设计能够减少局部损坏对整体数据的影响。\n- **页面头部损坏**：当页面头部损坏时，该列块中的所有后续页面将无法读取。\n- **页面数据损坏**：如果某个页面的数据损坏，通常只会导致该页面的数据不可用，其它页面的数据仍然可用。\n\n较小的行组设置可以更好地抵抗数据损坏，因为损坏只会影响较小的数据范围，而不会影响整个文件。\n\n## 3.9 推荐的配置参数\n\n为了实现最佳的性能和可靠性，Parquet 提供了一些推荐配置：\n\n- **行组大小（Row group size）**：较大的行组可以使列块变得更大，进而提升顺序 IO 的性能。虽然较大的行组需要更多的内存缓存，但它能够有效减少 IO 操作次数，从而提升性能。Parquet 推荐的行组大小为 512MB 至 1GB。此外，行组最好与 HDFS 的 Block 大小对齐，以减少跨 Block 的 IO 操作。理想的配置是行组大小和 HDFS Block 大小均为 1GB，并保证每个 HDFS 文件对应一个 HDFS Block。\n\n- **数据页大小（Data page size）**：数据页是不可分割的存储单元。较小的数据页允许更精细的随机访问（如单行查找），但会增加 page header 的数量，从而带来空间开销。较大的数据页可以降低页面头部的开销，提升数据解析的效率。Parquet 推荐的数据页大小为 8KB，以在性能与空间利用率之间取得平衡。\n\n总结来看，Parquet 文件格式通过行组、列块、页面三级结构，结合丰富的元数据信息和多种编码方式，达到了高效的数据存储和读取性能。其列式存储特性使得数据的压缩率大幅提高，并能高效支持大规模的并行查询。对于需要处理海量数据的场景，Parquet 是一种高效而可靠的数据存储格式。\n\n# 4. Python使用Parquet\n## 4.1 安装依赖并导入\n```shell\npip install pyarrow pandas\n```\n```python\nimport pyarrow as pa\nimport pyarrow.parquet as pq\nimport pandas as pd\nfrom datetime import datetime\n```\n## 4.2 定义schema\n```python\nschema = pa.schema([\n    (\"id\", pa.int32()),\n    (\"speeds\", pa.list_(pa.float64())),\n    (\"trajectory\", pa.map_(\n        pa.timestamp('ms'),  \n        pa.struct([   \n            (\"latitude\", pa.float64()),\n            (\"longitude\", pa.float64())\n        ])\n    ))\n])\n```\n## 4.3 导入数据\n```python\ndata = [\n    {\n        \"id\": 1,\n        \"speeds\": [12.5, 13.2, 14.1],\n        \"trajectory\": {\n            datetime(2024, 11, 21, 10, 0): {\"latitude\": 40.7128, \"longitude\": -74.0060},\n            datetime(2024, 11, 21, 10, 5): None\n        }\n    },\n    {\n        \"id\": 2,\n        \"speeds\": [20.1, 21.3],\n        \"trajectory\": {\n            datetime(2024, 11, 21, 11, 0): {\"latitude\": 34.0522, \"longitude\": -118.2437}\n        }\n    }\n]\ndf = pd.DataFrame(data)\n```\n## 4.4 生成parquet文件\n```python\ncompression_method = 'gzip' #(snappy、lzo、brotli ...)\ntable = pa.Table.from_pandas(df, schema=schema)\npq.write_table(table, \"example.parquet\", compression_method)\n```\n\n## 4.4读取parquet文件并且查看格式信息\n### 4.4.1 读取parquet文件\n```python\nread_table = pq.read_table(\"exmaple.parquet\")\nprint(read_table.to_pandas())\n```\n```console\n  id        speeds                                         trajectory\n0   1  [45.5, 60.2]  [{'key': 2024-11-21 10:30:00, 'value': {'latit...\n1   2  [35.2, 50.0]  [{'key': 2024-11-21 11:00:00, 'value': {'latit...\n```\n\n### 4.4.2 查看schame&元信息\n```python\nparquet_file = pq.ParquetFile(\"example\")\nprint(\"元信息：\")\nprint(parquet_file.metadata)\nprint(\"\\nSchema：\")\nprint(parquet_file.schema)\n```\n```console\n 元信息：\n<pyarrow._parquet.FileMetaData object at 0x000002019E93A980>\n  created_by: parquet-cpp-arrow version 18.0.0-SNAPSHOT\n  num_columns: 5\n  num_rows: 2\n  num_row_groups: 1\n  format_version: 2.6\n  serialized_size: 3014\n\nSchema：\n<pyarrow._parquet.ParquetSchema object at 0x000002019E9F0A40>\nrequired group field_id=-1 schema {\n  optional int32 field_id=-1 id;\n  optional group field_id=-1 speeds (List) {\n    repeated group field_id=-1 list {\n      optional double field_id=-1 element;\n    }\n  }\n  optional group field_id=-1 trajectory (Map) {\n    repeated group field_id=-1 key_value {\n      required int64 field_id=-1 key (Timestamp(isAdjustedToUTC=false, timeUnit=milliseconds, is_from_converted_type=false, force_set_converted_type=false));\n      optional group field_id=-1 value {\n        optional double field_id=-1 latitude;\n        optional double field_id=-1 longitude;\n      }\n    }\n  }\n}\n```\n\n### 4.4.3 查看列信息\n```python\nrow_group = parquet_file.metadata.row_group(0)\nfor col_idx in range(parquet_file.metadata.num_columns):\n    column = row_group.column(col_idx)\n    column_name = parquet_file.schema.column(col_idx).name\n    print(f\"列 {col_idx} ({column_name}) 信息：\")\n    print(f\"  总值数量：{column.num_values}\")\n    print(f\"  压缩大小：{column.total_compressed_size} 字节\")\n    print(f\"  未压缩大小：{column.total_uncompressed_size} 字节\")\n    print(f\"  最大值：{column.statistics.max if column.statistics else '无统计信息'}\")\n    print(f\"  最小值：{column.statistics.min if column.statistics else '无统计信息'}\")\n    print(f\"  空值数量：{column.statistics.null_count if column.statistics else '无统计信息'}\")\n    print(\"---\")\n\n```\n```console\n  列 0 (id) 信息：\n  总值数量：2\n  压缩大小：80 字节\n  未压缩大小：76 字节\n  最大值：2\n  最小值：1\n  空值数量：0\n---\n列 1 (element) 信息：\n  总值数量：5\n  压缩大小：130 字节\n  未压缩大小：132 字节\n  最大值：21.3\n  最小值：12.5\n  空值数量：0\n---\n列 2 (key) 信息：\n  总值数量：3\n  压缩大小：119 字节\n  未压缩大小：115 字节\n  最大值：2024-11-21 11:00:00\n  最小值：2024-11-21 10:00:00\n  空值数量：0\n---\n列 3 (latitude) 信息：\n  总值数量：3\n  压缩大小：119 字节\n  未压缩大小：115 字节\n  最大值：40.7138\n  最小值：34.0522\n  空值数量：0\n---\n列 4 (longitude) 信息：\n  总值数量：3\n  压缩大小：119 字节\n  未压缩大小：115 字节\n  最大值：-74.006\n  最小值：-118.2437\n  空值数量：0\n---\n```\n\n### 4.4.4 查看列编码方式\n```python\nfor col_idx in range(parquet_file.metadata.num_columns):\n    column_encoding = parquet_file.metadata.row_group(0).column(col_idx).encodings\n    column_name = parquet_file.schema.column(col_idx).name\n    print(f\"列 {col_idx} ({column_name}) 编码方式：\")\n    print(f\"  Encodings: {column_encoding}\")\n    print(\"---\")\n```\n```console\n列 0 (id) 编码方式：\n  Encodings: ('PLAIN', 'RLE', 'RLE_DICTIONARY')\n---\n列 1 (element) 编码方式：\n  Encodings: ('PLAIN', 'RLE', 'RLE_DICTIONARY')\n---\n列 2 (key) 编码方式：\n  Encodings: ('PLAIN', 'RLE', 'RLE_DICTIONARY')\n---\n列 3 (latitude) 编码方式：\n  Encodings: ('PLAIN', 'RLE', 'RLE_DICTIONARY')\n---\n列 4 (longitude) 编码方式：\n  Encodings: ('PLAIN', 'RLE', 'RLE_DICTIONARY')\n---\n```\n\n# 5. 总结\n本文详细介绍了 Apache Parquet 格式的原理与实践，重点讲解了其列式存储结构、嵌套数据支持、编码与压缩技术、以及如何在 Python 中使用 Parquet 文件。Parquet 的设计充分利用了列式存储的优势，特别是在大数据分析场景中，它能够显著提高查询效率并有效节省存储空间。\n\n1. **列式存储优势**：Parquet 的列式存储方式使得在进行数据分析时，可以只读取所需的列，减少了不必要的磁盘 I/O 操作。此外，列式存储能高效地压缩数据，特别是对于重复性高的数据，能够显著减少存储空间的占用。\n\n2. **复杂嵌套结构支持**：通过使用 Repetition Levels 和 Definition Levels，Parquet 能够高效处理复杂的嵌套数据结构，例如 List 和 Map。这种设计让 Parquet 格式在处理包含多个嵌套字段的复杂数据时，保持高效且灵活。\n\n3. **编码与压缩技术**：Parquet 支持多种编码方式（如 PLAIN、DICTIONARY、RLE 编码等）和压缩算法（如 Snappy、GZIP、LZO 等）。这些技术帮助优化存储空间并提升数据读取性能。在不同的场景下，用户可以选择适合的编码和压缩方法，以平衡存储与速度的需求。\n\n4. **Python 使用 Parquet**：通过 `pyarrow` 库，Python 用户能够轻松地创建、读取和操作 Parquet 文件。示例代码展示了如何定义 Parquet 文件的 schema、将数据导入并生成 Parquet 文件，以及如何读取 Parquet 文件并查看其元数据和编码信息。\n\n5. **性能优化**：Parquet 的设计考虑了并行处理，支持高效的列读取操作，这对于大规模数据处理非常重要。它通过将数据划分为行组（Row Groups）、列块（Column Chunks）和页面（Pages），使得分布式计算框架如 Hadoop 和 Spark 能够高效地处理数据。\n\n总的来说，Parquet 是一种功能强大的数据存储格式，它结合了列式存储的优势与高效的压缩、编码技术，特别适合用于大数据分析和大规模分布式计算环境中。","source":"_posts/Parquet.md","raw":"---\ntitle: Parquet原理详解\ndate: 2024-11-18 10:26:54\ntags:\n  - parquet\n  - 文件存储\ncategories:\n  - 大数据\ncover: /images/cover_image/parquet.jpg\n---\n\nApache Parquet 是一种高效的列式存储格式，其设计初衷是优化大规模数据处理的性能与存储效率。在大数据领域，随着数据规模的迅速增长，如何高效地存储、读取和处理数据已成为关键问题。作为 Apache 软件基金会支持的开源项目，Parquet 凭借卓越的数据压缩率和快速查询能力，被广泛应用于各类大数据处理场景。本文旨在从理论与实践的双重视角，系统分析 Apache Parquet 的设计理念、核心架构与技术实现，特别是其在处理复杂嵌套数据结构方面的独特优势，期望为研究者和开发者提供深入的理解与指导。\n\n---\n\n# 1. 基础概念\n\n## 1.1 列式存储 VS 行式存储\n\n**行式存储**：行式存储是将一行数据的所有字段连续存储在一起。例如，对于下表中的数据：\n\n| id | latitude   | longitude | timestamp  |\n| -- | ---------- | --------- | ---------- |\n| 23 | 106.551556 | 29.563761 | 1732118400 |\n| 46 | 106.480989 | 29.600298 | 1732161600 |\n| 99 | 106.512051 | 29.583541 | 1732183200 |\n\n在行式存储中，数据会按照以下方式存储：\n\n```\n23, 106.551556, 29.563761, 1732118400\n46, 106.480989, 29.600298, 1732161600\n99, 106.512051, 29.583541, 1732183200\n```\n\n每一行的数据被紧密地存储在一起，这样的存储方式便于对单行数据的增、删、改、查操作。 在行式存储模式下，整行数据的存取非常高效，尤其是在需要获取或修改完整的一行数据时，能够显著提高访问效率。行式存储的优点：\n1. **快速定位整行数据**：行式存储能够快速定位到某一行的数据。例如，当查询id=46的数据时，只需从存储中直接读取这一行，所有字段都能一次性高效返回。\n2. **事务操作支持好**：行式存储非常适合高频的增删改操作，例如修改id=23这一行的timestamp值。这种操作只需要定位到该行并进行更新，整体效率非常高。\n\n如果需要查询或更新id=46的所有数据，行式存储可以快速定位到46, 106.480989, 29.600298, 1732161600` 这一整行数据，并进行操作，而无需访问其他数据，因而效率非常高。行式存储特别适合 OLTP（在线事务处理）场景，电商系统、银行系统等需要频繁处理单条记录的增删改操作的应用中，行式存储表现尤为出色。\n\n\n**列式存储**：与行式存储不同，列式存储将同一列的数据连续存储在一起。对于上面的示例表格，列式存储方式如下：\n\n```\nid:        23, 46, 99\nlatitude:  106.551556, 106.480989, 106.512051\nlongitude: 29.563761, 29.600298, 29.583541\ntimestamp: 1732118400, 1732161600, 1732183200\n```\n\n在这种存储模式下，每列的数据在物理存储中是连续存放的，列与列之间的数据相互独立。列式存储更适合对某些列进行查询，例如在大数据分析中仅需要查询latitude和longitude，而无需加载其他字段。列式存储的优点：\n1. **按列查询性能高**：在数据分析场景中，查询操作往往只涉及少数列，例如筛选latitude接近106.5的数据。在列式存储中，只需读取 latitude列即可，这显著减少了 I/O 操作和内存占用，提高了查询效率。\n2. **压缩效果好**：由于同一列的数据类型相同且分布相似，列式存储能够实现高效压缩。例如，timestamp列的值有一定规律性，这样的数据在列式存储中可以被压缩得非常紧凑，从而节省存储空间并加速处理。\n\n如果需要查找所有记录的latitude，列式存储只需要读取106.551556, 106.480989, 106.512051这一列的数据，跳过其他列的数据，减少了读取不必要数据的开销，这对于大规模数据分析非常高效。 列式存储非常适合OLAP（在线分析处理）场景，尤其在数据仓库、大规模数据分析等需要对大量数据进行聚合、过滤和统计计算的应用中，列式存储能够显著提高查询效率。\n\n# 2. Parquet详解\n\n## 2.1 数据模型\nParquet采用了一个类似Google Protobuf的协议来描述存储数据的schema，以下面这个schema为例介绍Parquet的数据模型。\n```\nmessage SpatialTemporalData {\n  required int32 id;\n  repeated double speeds;\n  repeated group trajectory {\n    required timestamp timestamp;\n    optional group location {\n      required double latitude;  \n      required double longitude; \n    }\n  }\n}\n```\n在这个schema中，每条记录代表一条轨迹。每条记录中有且仅有一个id，每个id可以对应0个或多个speeds和trajectory。每个trajectory必须包含一个timestamp，location字段则为可选字段。每个location必须包含唯一的latitude和longitude。在 schema的顶层是message，它可以包含多个字段。每个字段具有三个属性：**重复性**（repetition）、**类型**（type）和 **名字**（name）。\n\n字段的重复性包含三种：\n* required：有且只有一次\n* optional：0次或1次\n* repeated：0次或多次\n\n字段的类型包括：\n* 基础数据类型（物理上只存储基础数据类型）：BOOLEAN、INT32、INT64、INT96、FLOAT、DOUBLE、BYTE_ARRAY、FIXED_LEN_BYTE_ARRAY\n* 逻辑数据类型（指导如何转换成基础数据类型进行存储）：\n  * 字符串类型：STRING、ENUM、UUID\n  * 数字类型：有符号整数，无符号整数 INT(8/16/32/64, true/false)\n  * 十进制：DECIMAL\n  * 时间类型：DATE、TIME、TIMESTAMP\n  * 嵌入类型：JSON、BSON、VARIANT\n  * 嵌套类型：LIST（需要三级嵌套），MAP(需要三级嵌套)\n  * 空值\n\nLIST可以用repeated field来表示：\n```\nrepeated double speeds;\n=========================================================>(parquet格式)\noptional group field_id=-1 speeds (List) {\n    repeated group field_id=-1 list {\n      optional double field_id=-1 element;\n    }\n  }\n```\nMap可以用包含key-value对且key是required的repeated group来表示：\n```\nrepeated group trajectory {\n    required timestamp timestamp;\n    optional group location {\n      required double latitude;  \n      required double longitude; \n    }\n  }\n=========================================================>(parquet格式)\noptional group field_id=-1 trajectory (Map) {\n    repeated group field_id=-1 key_value {\n      required int64 field_id=-1 key (Timestamp);\n      optional group field_id=-1 value {\n        optional double field_id=-1 latitude;\n        optional double field_id=-1 longitude;\n      }\n    }\n  }\n```\n\n## 2.2 列式存储格式\n在Parquet格式的存储中，一个schema的树结构有几个叶子节点（叶子节点都是基础数据类型），实际的存储中就会有多少column。 上面SpatialTemporalData的schema的树结构如图所示：\n\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/schema.png\" style=\"width:66%;\"/>\n</div>\n\n这个schema实际存储5列，如表所示:\n\n| Column    | Type      | \n|-----------|-----------| \n| id        | INT32     | \n| speeds    | DOUBLE    | \n| timestamp | TIMESTAMP | \n| latitude  | DOUBLE    | \n| longitude | DOUBLE    | \n\n## 2.3 Repetition and Definition Levels\nParquet文件采用按列存储的方式，但面对复杂的嵌套结构时，由于嵌套和重复的位置难以确定，恢复原始嵌套结构变得具有一定挑战性。为了解决这一问题，Parquet使用了 **striping and assembly** 算法，通过为每条数据增加 **Repetition Levels** 和 **Definition Levels**，实现对嵌套结构的精准还原。得益于这种设计，任意字段的恢复无需依赖其他字段，同时还支持按照原始嵌套格式对任意字段子集进行重建，大大提升了数据解析的灵活性与效率。以下面表格中的数据为例：\n\n| **id** | **speeds**         | **trajectory.timestamp** | **trajectory.latitude** | **trajectory.longitude** |\n|--------|--------------------|--------------------------|-------------------------|--------------------------|\n| 1      | [12.5, 13.2, 14.1] | 2024-11-21 10:00:00      | 40.7128                 | -74.0060                 |\n|        |                    | 2024-11-21 10:05:00      | NULL                    | NULL                     |\n| 2      | [20.1, 21.3]       | 2024-11-21 11:00:00      | 34.0522                 | -118.2437                |\n\n### 2.3.1 Repetition Levels\n**Repetition Level** 用于表示当前值在路径中的重复层级，即该值位于哪个重复字段的结构中。 Repetition Level 专门用来处理重复字段。以 speeds 和 trajectory 为例：\n1. **speeds 字段**  \n   speeds 是一个列表类型字段，包含值 [12.5, 13.2, 14.1]。每个值的 Repetition Level 分别为 0、1 和 1：\n   - 12.5 是列表的第一个值（即列表的起点），因此它的 Repetition Level 为 0。\n   - 后续的值 13.2 和 14.1 都属于同一个列表，表示列表的后续元素，因此它们的 Repetition Level 为 1。\n\n2. **trajectory 字段**  \n   trajectory 是一个 Map 类型，其键为时间戳，值为包含经纬度的结构体。对于每个 Map 键值对：\n   - 第一个键值对（时间戳为 2024-11-21 10:00:00）：这是 Map 的第一个值，因此 Repetition Level 为 0。\n   - 第二个键值对（时间戳为 2024-11-21 10:05:00）：这是同一个 Map 中的第二个值，因此它的 Repetition Level 为 1，表示 Map 的重复部分。虽然纬度和经度的值为空，这些字段的 Repetition Level 依然为 1。\n   - 空值的状态不会影响 Repetition Level，而是通过 Definition Level 来表示。\n\n### 2.3.2 Definition Levels\n**Definition Level** 表示路径上有多少可选字段被定义。嵌套数据类型的一个特点是，某些字段（例如可选字段或重复字段）可以为空，或者未被定义。如果一个字段被定义了，那么它的所有父节点也都必须是已定义的。从根节点开始遍历，当某个字段的路径上某个节点为空时，我们记录当前的深度作为该字段的 Definition Level。如果某字段的 Definition Level 达到了它的最大值，就说明该字段是有数据的。对于必须字段（如 required 类型），字段始终是定义的，因此 Definition Level 不需要特别标明。而对于可选字段（如 optional 类型），Definition Level 用于区分字段是未定义（为空）还是有值。在关系型数据中，Definition Level 为 0 表示字段未定义，1 或更高表示字段已定义并可能有值。\n\n1. **在 speeds 字段中**：\n   - speeds 是一个列表字段，其元素是可选的。当列表中某个元素有值时，例如 12.5，它的 Definition Level 为 1，表示该元素被定义且有数据。\n   - 如果 speeds 列表为空，Definition Level 为 0，表示 speeds 未被定义。\n2. **在 trajectory 字段中**：\n   - trajectory 是一个 Map 类型字段，键为时间戳，值为嵌套的纬度和经度字段。\n   - 当时间戳键值对中，纬度和经度都有值时，例如 latitude = 40.7128 和 longitude = -74.0060，Definition Level 为 2，表示字段完全定义且有值。\n   - 如果某个时间戳的纬度和经度值为空（例如 timestamp 为 2024-11-21 10:05:00 的键值对），Definition Level 会降为 1，表示字段已定义但没有数据。\n   - 如果整个 trajectory 字段为空，Definition Level 为 0，表示字段未被定义。\n\n### 2.3.3 计算过程\n以下是第一条和第二条数据的 Repetition Level (R) 和 Definition Level (D) 的计算过程整合：\n\n对于第一条数据：\n- **id** 是标量字段，没有嵌套或重复，Repetition Level (R) 固定为 0，Definition Level (D) 固定为 0，表示字段始终定义并有值。\n- **speeds** 是一个列表，第一个元素 12.5 表示列表的起点，因此 R=0，D=1；后续的 13.2 和 14.1 属于同一列表，因此 R=1，D=1，表明字段存在且有值。\n- **trajectory.timestamp** 是Map的键，第一个键值对2024-11-21 10:00:00是 Map 的起点，R=0，D=2，表明键和值都定义且非空；第二个键值对2024-11-21 10:05:00是 Map 中的后续键值对，R=1，D=1，表明键已定义但值为空。\n- **trajectory.latitude** 和 **trajectory.longitude** 是 Map 值中的嵌套字段，2024-11-21 10:00:00对应的纬度和经度都存在（由于是required字段，与上一层保持相同），因此 R=0，D=2；2024-11-21 10:05:00的纬度和经度为空，R=1，D=1，表示字段已定义但无值。\n\n对于第二条数据：\n- **id** 是标量字段，与第一条类似，Repetition Level (R) 固定为0，Definition Level (D) 固定为0。\n- **speeds** 是一个列表，第一个元素 20.1 表示列表的起点，因此 R=0，D=1；后续的 21.3 属于同一列表，因此 R=1，D=1，表明字段存在且有值。\n- **trajectory.timestamp** 是Map的键，只有一个键值对2024-11-21 11:00:00，因此 R=0，D=2，表明键和值都定义且非空。\n- **trajectory.latitude** 和 **trajectory.longitude** 是 Map 值中的嵌套字段，2024-11-21 11:00:00对应的纬度和经度都存在，因此 R=0，D=2，表示字段已定义且有值。\n\n| **Column** | **Value** | **R** | **D** | **Column**               | **Value**           | **R** | **D** |\n|------------|-----------|-------|-------|--------------------------|---------------------|-------|-------|\n| **id**     | 1         | 0     | 0     | **trajectory.timestamp** | 2024-11-21 10:00:00 | 0     | 2     |\n|            | 2         | 0     | 0     |                          | 2024-11-21 10:05:00 | 1     | 1     |\n| **speeds** | 12.5      | 0     | 1     |                          | 2024-11-21 11:00:00 | 0     | 2     |\n|            | 13.2      | 1     | 1     | **trajectory.latitude**  | 40.7128             | 0     | 2     |\n|            | 14.1      | 1     | 1     |                          | NULL                | 1     | 1     |\n|            | 20.1      | 0     | 1     |                          | 34.0522             | 0     | 2     |\n|            | 21.3      | 1     | 1     | **trajectory.longitude** | -74.0060            | 0     | 2     |\n|            |           |       |       |                          | NULL                | 1     | 1     |\n|            |           |       |       |                          | -118.2437           | 0     | 2     |\n\n### 2.3.4 存储分析\n在Parquet中，所有字段会被展平为单独的列，每列存储其实际数据，同时附加R和D两列来记录层级结构和字段状态。Parquet并不存储NULL值，而是通过D的值来判断字段是否被定义。例如，Definition Level小于最大值时表示字段为空(NULL)。对于嵌套字段和重复字段（如MAP和LIST），R的值则用于区分新记录与同一结构中的后续值。\n\n这种设计的优点在于，它可以在保持数据层级关系的同时，避免存储冗余的层级结构信息。同时，由于R和D只需要几位就可以表示字段的状态（如7层结构只需要3bit + 3bit 就能表示R和D），存储开销极小。空字段无需存储实际值，仅通过R和D即可高效表示。这种机制使得Parquet格式在处理嵌套数据时既保持了灵活性，又显著提升了存储和读取效率。\n\n## 2.4 编码与压缩技术\n\n### 2.4.1 编码\n编码是将数据转换为更紧凑的格式，以减少存储空间或提高计算效率。Parquet 使用了几种常见的编码方式来对数据进行编码，这些编码方式有助于在存储时减少数据的冗余，提高读取性能。\n\n1. **PLAIN编码**：PLAIN编码是Parquet中最基础的编码方式，它将原始数据直接存储，没有进行任何压缩或变换。该编码方式简单且高效，适用于数据分布均匀的场景，但可能会占用较多存储空间。PLAIN 编码通常用于存储不需要特别优化的字段数据，如简单的整数或字符串。\n2. **DICTIONARY编码**：DICTIONARY编码是一种通过使用字典（映射表）将数据中的重复值替换为字典索引的编码方式。该编码方法适用于有大量重复值的数据类型，比如类别型数据。在Parquet中，数据被分成多个区块，每个区块都会为该区块内的数据生成一个字典。存储时，数据中的重复项会被替换为字典的索引，进而节省存储空间。例如，如果一个字段中有多个相同的值，那么这些值将被映射为字典的索引，存储时只需保存索引而不是重复的值。这种方法能够显著降低存储空间，但需要为每个数据块生成字典，可能会增加读取时的解码开销。\n3. **RLE（Run-Length Encoding）编码**：RLE（Run-Length Encoding）编码是通过记录连续相同值的数量来压缩数据的一种方式。在数据中，若出现连续相同的值，RLE 会记录这些值出现的次数，从而将重复的数据压缩成更小的表示形式。RLE 编码特别适用于数据中存在大量连续相同值的情况。例如，如果一个字段连续出现 100 个相同的数字，那么 RLE 会将其压缩为“值+出现次数”的形式。在 Parquet 中，RLE 编码常用于布尔类型数据或者重复出现的数字类型数据。\n4. **位打包（Bit-Packing）编码**：位打包（Bit-Packing）是一种将多个小数据类型压缩为更小比特数表示的编码方式。该方法通过打包多个值来提高存储效率，通常用于存储较小的数据类型，如整数、布尔值等。Bit-Packing 可以将每个字段中的数据值压缩为最小的比特位数，从而减少存储空间。\n5. **DELTA 编码**：DELTA编码是一种记录数据与其前一个值差异的编码方式。这种方法非常适合存储数值范围比较小且增减变化不大的数据。例如，对于一个增长规律较为平稳的数字序列，DELTA 编码将存储每个数值与前一个数值的差异，而不是存储完整的数值。这样可以显著降低存储空间，特别是对于时间序列数据或连续数据。\n\n### 2.4.2 编码压缩技术\n压缩是将数据进一步减少存储空间的技术。Parquet支持多种压缩算法，可以在不牺牲数据质量的情况下，进一步压缩数据以节省存储空间。常见的压缩算法包括Snappy、GZIP、LZO、Brotli等。\n1. Snappy压缩：Snappy 是 Google 开发的一种压缩算法，具有非常快的压缩和解压缩速度。它的压缩比虽然不如 GZIP，但由于其高效的速度，特别适合大数据处理场景中实时数据处理的需求。Snappy 通常是 Parquet 默认的压缩算法，尤其适用于对速度要求较高的场景。\n2. GZIP压缩：GZIP是一种较为常见的压缩算法，相较于Snappy，它的压缩比更高，但速度较慢。GZIP压缩适用于对存储空间有较高要求的场景，尤其是当存储成本较高或数据量特别大的时候。GZIP的高压缩比使得它能有效减少存储需求，但解压缩的速度可能成为瓶颈。\n3. LZO压缩：LZO是一种快速的压缩算法，类似于Snappy，适用于需要快速压缩和解压缩的场景。LZO的压缩比一般不如GZIP，但它的速度非常快，适合于大数据分析中对压缩速度要求较高的应用场景。\n4. Brotli压缩：Brotli 是由Google开发的一种压缩算法，常用于Web数据传输中的压缩。Brotli的压缩比比GZIP更高，并且其解压速度也较为高效。近年来，Brotli也开始在Parquet中被使用，尤其适用于对存储需求有较高要求的场景。\n5. Zstandard（ZSTD）压缩：Zstandard（ZSTD）是一种新兴的压缩算法，旨在提供比 GZIP 更高的压缩比和更快的解压速度。ZSTD 兼具了较高的压缩效率和较低的延迟，非常适合需要平衡存储与速度的应用场景。\n\n# 3. Parquet具体实现\n\n## 3.1 Parquet 文件存储格式中的术语\n\n在理解 Parquet 文件的存储结构时，熟悉其中关键术语至关重要。以下是 Parquet 中一些核心术语的定义：\n\n- **Block (HDFS 块)**：这是 Hadoop 分布式文件系统（HDFS）中数据存储的基本单元，Parquet 文件完全兼容 HDFS 的设计。Block 的大小在 Hadoop 1.x 版本中默认为 64MB，而在 Hadoop 2.x 版本中则增加至 128MB。HDFS 使用 Block 的副本机制来确保数据的冗余和容错能力，从而提高了系统的可靠性和稳定性。\n\n- **File (文件)**：这是存储在 HDFS 上的一个逻辑实体，包含文件的元数据信息，但其实际数据内容由多个 HDFS Block 保存。\n\n- **Row Group (行组)**：Parquet 将数据按行划分为多个逻辑上的水平分区。每个 Row Group 包含该组中所有列的列块（Column Chunk），是并行化和 IO 操作的基本单元。这样设计使得每个行组都可以独立解码，便于分布式处理。\n\n- **Column Chunk (列块)**：指单列数据在一个行组中的物理存储。列块在行组中是逻辑连续的，这种设计允许对列进行有效的压缩和编码，从而提高了存储的利用率。\n\n- **Page (页面)**：列块被进一步划分为多个 Page，这是 Parquet 文件压缩和编码的最小基本单元。每个列块中可能包含多个类型的 Page，例如数据页面、字典页面等。\n\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/format.png\" style=\"width:66%;\"/>\n</div>\n\n## 3.2 并行化执行的基本单元\n\n在 Parquet 文件中，不同层级的数据单元在并行化处理和 IO 操作中发挥不同的作用：\n\n- **MapReduce 任务划分**：在使用 Hadoop 的 MapReduce 框架处理数据时，通常以 File 或 Row Group 为基本单位来分配任务，即每个任务处理一个完整的文件或者一个行组，从而实现并行化。\n\n- **IO 操作**：Parquet 文件的 IO 操作以 Column Chunk 为基本单位进行。这种设计方式使得可以只读取所需列的数据，减少不必要的磁盘 IO，从而提高读取效率。\n\n- **编码和压缩**：在 Parquet 中，编码和压缩通常以 Page 为单位进行。每个页面可以使用不同的编码方法来提高压缩率，例如使用 RLE（Run Length Encoding）对重复值进行压缩，从而降低存储空间。\n\n## 3.3 Parquet 文件格式\n\nParquet 文件格式具有自解析的特性，文件使用 Thrift 格式定义 schema 以及其他元数据信息。这些元数据信息存储在文件末尾，方便读取时直接访问。\n\n典型的 Parquet 文件结构如下：\n\n- 整个文件被划分为多个行组，每个行组包含所有列的数据块和元数据信息。\n- 文件的元数据存储在数据部分的最后，包含了所有列块元数据的起始位置。\n\n这种将元数据存储在文件末尾的设计，使得在写入数据时可以顺序高效地写入文件，同时在读取文件时可以快速获取元数据并定位到相关数据块。\n\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/metadata.png\" style=\"width:66%;\"/>\n</div>\n\n## 3.4 元数据信息\n\nParquet 文件包含三种不同类型的元数据，每种元数据在不同层级描述文件的内容和结构：\n\n- **文件元数据**：描述整个文件的结构和内容，例如行组和列块的位置信息等，是文件级别的数据概览。\n- **列（块）元数据**：描述单个列块的详细信息，包括该列块的属性、位置和大小。这些元数据使得读取特定列块变得更加高效。\n- **页面头部元数据**：描述每个页面的具体属性，包括编码方式、压缩方法、页面位置等。这些元数据对于解码和读取页面中的数据至关重要。\n\n## 3.5 并行读取与列存储的优化\n\nParquet 的设计充分考虑了并行处理和列存储的优势。由于数据是按列存储的，因此可以非常高效地进行列的读取操作。尤其是对于只需要部分列的查询，Parquet 能够显著减少 IO 开销，提升性能。每个行组中的列块在物理上保持连续存储，这样即使是大规模并行读取也可以最大程度减少磁盘寻道时间。\n\n## 3.6 编码（Encoding）\n\nParquet 支持多种编码方式，以优化数据的压缩和读取效率。细节可以参考官方文档：[Parquet Encodings](https://github.com/apache/parquet-format/blob/master/Encodings.md)。通过采用不同的编码方法，Parquet 能够大幅度减少重复值存储，从而节省磁盘空间。\n\n## 3.7 Column Chunks 存储与读取\n\n每个 Column Chunk 是由多个 Page 组成的。在读取数据时，Parquet Reader 可以利用页面头部元数据中存储的信息，直接跳过不感兴趣的页面。例如，字典页面与数据页面存储的内容类型不同，Reader 可以根据需求决定是否需要加载某些页面，从而优化查询性能。\n\n## 3.8 错误处理机制\n\nParquet 文件设计了一系列机制来应对数据损坏的情况，以保证数据的可用性和可靠性：\n\n- **文件元数据损坏**：如果整个文件的元数据损坏，通常情况下整个文件会无法读取。\n- **列元数据损坏**：如果某个列的元数据损坏，只会影响该列块的读取，其他行组中相同列的块仍可正常使用，这种设计能够减少局部损坏对整体数据的影响。\n- **页面头部损坏**：当页面头部损坏时，该列块中的所有后续页面将无法读取。\n- **页面数据损坏**：如果某个页面的数据损坏，通常只会导致该页面的数据不可用，其它页面的数据仍然可用。\n\n较小的行组设置可以更好地抵抗数据损坏，因为损坏只会影响较小的数据范围，而不会影响整个文件。\n\n## 3.9 推荐的配置参数\n\n为了实现最佳的性能和可靠性，Parquet 提供了一些推荐配置：\n\n- **行组大小（Row group size）**：较大的行组可以使列块变得更大，进而提升顺序 IO 的性能。虽然较大的行组需要更多的内存缓存，但它能够有效减少 IO 操作次数，从而提升性能。Parquet 推荐的行组大小为 512MB 至 1GB。此外，行组最好与 HDFS 的 Block 大小对齐，以减少跨 Block 的 IO 操作。理想的配置是行组大小和 HDFS Block 大小均为 1GB，并保证每个 HDFS 文件对应一个 HDFS Block。\n\n- **数据页大小（Data page size）**：数据页是不可分割的存储单元。较小的数据页允许更精细的随机访问（如单行查找），但会增加 page header 的数量，从而带来空间开销。较大的数据页可以降低页面头部的开销，提升数据解析的效率。Parquet 推荐的数据页大小为 8KB，以在性能与空间利用率之间取得平衡。\n\n总结来看，Parquet 文件格式通过行组、列块、页面三级结构，结合丰富的元数据信息和多种编码方式，达到了高效的数据存储和读取性能。其列式存储特性使得数据的压缩率大幅提高，并能高效支持大规模的并行查询。对于需要处理海量数据的场景，Parquet 是一种高效而可靠的数据存储格式。\n\n# 4. Python使用Parquet\n## 4.1 安装依赖并导入\n```shell\npip install pyarrow pandas\n```\n```python\nimport pyarrow as pa\nimport pyarrow.parquet as pq\nimport pandas as pd\nfrom datetime import datetime\n```\n## 4.2 定义schema\n```python\nschema = pa.schema([\n    (\"id\", pa.int32()),\n    (\"speeds\", pa.list_(pa.float64())),\n    (\"trajectory\", pa.map_(\n        pa.timestamp('ms'),  \n        pa.struct([   \n            (\"latitude\", pa.float64()),\n            (\"longitude\", pa.float64())\n        ])\n    ))\n])\n```\n## 4.3 导入数据\n```python\ndata = [\n    {\n        \"id\": 1,\n        \"speeds\": [12.5, 13.2, 14.1],\n        \"trajectory\": {\n            datetime(2024, 11, 21, 10, 0): {\"latitude\": 40.7128, \"longitude\": -74.0060},\n            datetime(2024, 11, 21, 10, 5): None\n        }\n    },\n    {\n        \"id\": 2,\n        \"speeds\": [20.1, 21.3],\n        \"trajectory\": {\n            datetime(2024, 11, 21, 11, 0): {\"latitude\": 34.0522, \"longitude\": -118.2437}\n        }\n    }\n]\ndf = pd.DataFrame(data)\n```\n## 4.4 生成parquet文件\n```python\ncompression_method = 'gzip' #(snappy、lzo、brotli ...)\ntable = pa.Table.from_pandas(df, schema=schema)\npq.write_table(table, \"example.parquet\", compression_method)\n```\n\n## 4.4读取parquet文件并且查看格式信息\n### 4.4.1 读取parquet文件\n```python\nread_table = pq.read_table(\"exmaple.parquet\")\nprint(read_table.to_pandas())\n```\n```console\n  id        speeds                                         trajectory\n0   1  [45.5, 60.2]  [{'key': 2024-11-21 10:30:00, 'value': {'latit...\n1   2  [35.2, 50.0]  [{'key': 2024-11-21 11:00:00, 'value': {'latit...\n```\n\n### 4.4.2 查看schame&元信息\n```python\nparquet_file = pq.ParquetFile(\"example\")\nprint(\"元信息：\")\nprint(parquet_file.metadata)\nprint(\"\\nSchema：\")\nprint(parquet_file.schema)\n```\n```console\n 元信息：\n<pyarrow._parquet.FileMetaData object at 0x000002019E93A980>\n  created_by: parquet-cpp-arrow version 18.0.0-SNAPSHOT\n  num_columns: 5\n  num_rows: 2\n  num_row_groups: 1\n  format_version: 2.6\n  serialized_size: 3014\n\nSchema：\n<pyarrow._parquet.ParquetSchema object at 0x000002019E9F0A40>\nrequired group field_id=-1 schema {\n  optional int32 field_id=-1 id;\n  optional group field_id=-1 speeds (List) {\n    repeated group field_id=-1 list {\n      optional double field_id=-1 element;\n    }\n  }\n  optional group field_id=-1 trajectory (Map) {\n    repeated group field_id=-1 key_value {\n      required int64 field_id=-1 key (Timestamp(isAdjustedToUTC=false, timeUnit=milliseconds, is_from_converted_type=false, force_set_converted_type=false));\n      optional group field_id=-1 value {\n        optional double field_id=-1 latitude;\n        optional double field_id=-1 longitude;\n      }\n    }\n  }\n}\n```\n\n### 4.4.3 查看列信息\n```python\nrow_group = parquet_file.metadata.row_group(0)\nfor col_idx in range(parquet_file.metadata.num_columns):\n    column = row_group.column(col_idx)\n    column_name = parquet_file.schema.column(col_idx).name\n    print(f\"列 {col_idx} ({column_name}) 信息：\")\n    print(f\"  总值数量：{column.num_values}\")\n    print(f\"  压缩大小：{column.total_compressed_size} 字节\")\n    print(f\"  未压缩大小：{column.total_uncompressed_size} 字节\")\n    print(f\"  最大值：{column.statistics.max if column.statistics else '无统计信息'}\")\n    print(f\"  最小值：{column.statistics.min if column.statistics else '无统计信息'}\")\n    print(f\"  空值数量：{column.statistics.null_count if column.statistics else '无统计信息'}\")\n    print(\"---\")\n\n```\n```console\n  列 0 (id) 信息：\n  总值数量：2\n  压缩大小：80 字节\n  未压缩大小：76 字节\n  最大值：2\n  最小值：1\n  空值数量：0\n---\n列 1 (element) 信息：\n  总值数量：5\n  压缩大小：130 字节\n  未压缩大小：132 字节\n  最大值：21.3\n  最小值：12.5\n  空值数量：0\n---\n列 2 (key) 信息：\n  总值数量：3\n  压缩大小：119 字节\n  未压缩大小：115 字节\n  最大值：2024-11-21 11:00:00\n  最小值：2024-11-21 10:00:00\n  空值数量：0\n---\n列 3 (latitude) 信息：\n  总值数量：3\n  压缩大小：119 字节\n  未压缩大小：115 字节\n  最大值：40.7138\n  最小值：34.0522\n  空值数量：0\n---\n列 4 (longitude) 信息：\n  总值数量：3\n  压缩大小：119 字节\n  未压缩大小：115 字节\n  最大值：-74.006\n  最小值：-118.2437\n  空值数量：0\n---\n```\n\n### 4.4.4 查看列编码方式\n```python\nfor col_idx in range(parquet_file.metadata.num_columns):\n    column_encoding = parquet_file.metadata.row_group(0).column(col_idx).encodings\n    column_name = parquet_file.schema.column(col_idx).name\n    print(f\"列 {col_idx} ({column_name}) 编码方式：\")\n    print(f\"  Encodings: {column_encoding}\")\n    print(\"---\")\n```\n```console\n列 0 (id) 编码方式：\n  Encodings: ('PLAIN', 'RLE', 'RLE_DICTIONARY')\n---\n列 1 (element) 编码方式：\n  Encodings: ('PLAIN', 'RLE', 'RLE_DICTIONARY')\n---\n列 2 (key) 编码方式：\n  Encodings: ('PLAIN', 'RLE', 'RLE_DICTIONARY')\n---\n列 3 (latitude) 编码方式：\n  Encodings: ('PLAIN', 'RLE', 'RLE_DICTIONARY')\n---\n列 4 (longitude) 编码方式：\n  Encodings: ('PLAIN', 'RLE', 'RLE_DICTIONARY')\n---\n```\n\n# 5. 总结\n本文详细介绍了 Apache Parquet 格式的原理与实践，重点讲解了其列式存储结构、嵌套数据支持、编码与压缩技术、以及如何在 Python 中使用 Parquet 文件。Parquet 的设计充分利用了列式存储的优势，特别是在大数据分析场景中，它能够显著提高查询效率并有效节省存储空间。\n\n1. **列式存储优势**：Parquet 的列式存储方式使得在进行数据分析时，可以只读取所需的列，减少了不必要的磁盘 I/O 操作。此外，列式存储能高效地压缩数据，特别是对于重复性高的数据，能够显著减少存储空间的占用。\n\n2. **复杂嵌套结构支持**：通过使用 Repetition Levels 和 Definition Levels，Parquet 能够高效处理复杂的嵌套数据结构，例如 List 和 Map。这种设计让 Parquet 格式在处理包含多个嵌套字段的复杂数据时，保持高效且灵活。\n\n3. **编码与压缩技术**：Parquet 支持多种编码方式（如 PLAIN、DICTIONARY、RLE 编码等）和压缩算法（如 Snappy、GZIP、LZO 等）。这些技术帮助优化存储空间并提升数据读取性能。在不同的场景下，用户可以选择适合的编码和压缩方法，以平衡存储与速度的需求。\n\n4. **Python 使用 Parquet**：通过 `pyarrow` 库，Python 用户能够轻松地创建、读取和操作 Parquet 文件。示例代码展示了如何定义 Parquet 文件的 schema、将数据导入并生成 Parquet 文件，以及如何读取 Parquet 文件并查看其元数据和编码信息。\n\n5. **性能优化**：Parquet 的设计考虑了并行处理，支持高效的列读取操作，这对于大规模数据处理非常重要。它通过将数据划分为行组（Row Groups）、列块（Column Chunks）和页面（Pages），使得分布式计算框架如 Hadoop 和 Spark 能够高效地处理数据。\n\n总的来说，Parquet 是一种功能强大的数据存储格式，它结合了列式存储的优势与高效的压缩、编码技术，特别适合用于大数据分析和大规模分布式计算环境中。","slug":"Parquet","published":1,"updated":"2024-11-21T13:59:50.571Z","_id":"cm3rcvwhk0005usb000qkdl25","comments":1,"layout":"post","photos":[],"content":"<p>Apache Parquet 是一种高效的列式存储格式，其设计初衷是优化大规模数据处理的性能与存储效率。在大数据领域，随着数据规模的迅速增长，如何高效地存储、读取和处理数据已成为关键问题。作为 Apache 软件基金会支持的开源项目，Parquet 凭借卓越的数据压缩率和快速查询能力，被广泛应用于各类大数据处理场景。本文旨在从理论与实践的双重视角，系统分析 Apache Parquet 的设计理念、核心架构与技术实现，特别是其在处理复杂嵌套数据结构方面的独特优势，期望为研究者和开发者提供深入的理解与指导。</p>\n<hr>\n<h1 id=\"1-基础概念\"><a href=\"#1-基础概念\" class=\"headerlink\" title=\"1. 基础概念\"></a>1. 基础概念</h1><h2 id=\"1-1-列式存储-VS-行式存储\"><a href=\"#1-1-列式存储-VS-行式存储\" class=\"headerlink\" title=\"1.1 列式存储 VS 行式存储\"></a>1.1 列式存储 VS 行式存储</h2><p><strong>行式存储</strong>：行式存储是将一行数据的所有字段连续存储在一起。例如，对于下表中的数据：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>latitude</th>\n<th>longitude</th>\n<th>timestamp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>23</td>\n<td>106.551556</td>\n<td>29.563761</td>\n<td>1732118400</td>\n</tr>\n<tr>\n<td>46</td>\n<td>106.480989</td>\n<td>29.600298</td>\n<td>1732161600</td>\n</tr>\n<tr>\n<td>99</td>\n<td>106.512051</td>\n<td>29.583541</td>\n<td>1732183200</td>\n</tr>\n</tbody></table>\n<p>在行式存储中，数据会按照以下方式存储：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">23, 106.551556, 29.563761, 1732118400</span><br><span class=\"line\">46, 106.480989, 29.600298, 1732161600</span><br><span class=\"line\">99, 106.512051, 29.583541, 1732183200</span><br></pre></td></tr></table></figure>\n\n<p>每一行的数据被紧密地存储在一起，这样的存储方式便于对单行数据的增、删、改、查操作。 在行式存储模式下，整行数据的存取非常高效，尤其是在需要获取或修改完整的一行数据时，能够显著提高访问效率。行式存储的优点：</p>\n<ol>\n<li><strong>快速定位整行数据</strong>：行式存储能够快速定位到某一行的数据。例如，当查询id&#x3D;46的数据时，只需从存储中直接读取这一行，所有字段都能一次性高效返回。</li>\n<li><strong>事务操作支持好</strong>：行式存储非常适合高频的增删改操作，例如修改id&#x3D;23这一行的timestamp值。这种操作只需要定位到该行并进行更新，整体效率非常高。</li>\n</ol>\n<p>如果需要查询或更新id&#x3D;46的所有数据，行式存储可以快速定位到46, 106.480989, 29.600298, 1732161600&#96; 这一整行数据，并进行操作，而无需访问其他数据，因而效率非常高。行式存储特别适合 OLTP（在线事务处理）场景，电商系统、银行系统等需要频繁处理单条记录的增删改操作的应用中，行式存储表现尤为出色。</p>\n<p><strong>列式存储</strong>：与行式存储不同，列式存储将同一列的数据连续存储在一起。对于上面的示例表格，列式存储方式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id:        23, 46, 99</span><br><span class=\"line\">latitude:  106.551556, 106.480989, 106.512051</span><br><span class=\"line\">longitude: 29.563761, 29.600298, 29.583541</span><br><span class=\"line\">timestamp: 1732118400, 1732161600, 1732183200</span><br></pre></td></tr></table></figure>\n\n<p>在这种存储模式下，每列的数据在物理存储中是连续存放的，列与列之间的数据相互独立。列式存储更适合对某些列进行查询，例如在大数据分析中仅需要查询latitude和longitude，而无需加载其他字段。列式存储的优点：</p>\n<ol>\n<li><strong>按列查询性能高</strong>：在数据分析场景中，查询操作往往只涉及少数列，例如筛选latitude接近106.5的数据。在列式存储中，只需读取 latitude列即可，这显著减少了 I&#x2F;O 操作和内存占用，提高了查询效率。</li>\n<li><strong>压缩效果好</strong>：由于同一列的数据类型相同且分布相似，列式存储能够实现高效压缩。例如，timestamp列的值有一定规律性，这样的数据在列式存储中可以被压缩得非常紧凑，从而节省存储空间并加速处理。</li>\n</ol>\n<p>如果需要查找所有记录的latitude，列式存储只需要读取106.551556, 106.480989, 106.512051这一列的数据，跳过其他列的数据，减少了读取不必要数据的开销，这对于大规模数据分析非常高效。 列式存储非常适合OLAP（在线分析处理）场景，尤其在数据仓库、大规模数据分析等需要对大量数据进行聚合、过滤和统计计算的应用中，列式存储能够显著提高查询效率。</p>\n<h1 id=\"2-Parquet详解\"><a href=\"#2-Parquet详解\" class=\"headerlink\" title=\"2. Parquet详解\"></a>2. Parquet详解</h1><h2 id=\"2-1-数据模型\"><a href=\"#2-1-数据模型\" class=\"headerlink\" title=\"2.1 数据模型\"></a>2.1 数据模型</h2><p>Parquet采用了一个类似Google Protobuf的协议来描述存储数据的schema，以下面这个schema为例介绍Parquet的数据模型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message SpatialTemporalData &#123;</span><br><span class=\"line\">  required int32 id;</span><br><span class=\"line\">  repeated double speeds;</span><br><span class=\"line\">  repeated group trajectory &#123;</span><br><span class=\"line\">    required timestamp timestamp;</span><br><span class=\"line\">    optional group location &#123;</span><br><span class=\"line\">      required double latitude;  </span><br><span class=\"line\">      required double longitude; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个schema中，每条记录代表一条轨迹。每条记录中有且仅有一个id，每个id可以对应0个或多个speeds和trajectory。每个trajectory必须包含一个timestamp，location字段则为可选字段。每个location必须包含唯一的latitude和longitude。在 schema的顶层是message，它可以包含多个字段。每个字段具有三个属性：<strong>重复性</strong>（repetition）、<strong>类型</strong>（type）和 <strong>名字</strong>（name）。</p>\n<p>字段的重复性包含三种：</p>\n<ul>\n<li>required：有且只有一次</li>\n<li>optional：0次或1次</li>\n<li>repeated：0次或多次</li>\n</ul>\n<p>字段的类型包括：</p>\n<ul>\n<li>基础数据类型（物理上只存储基础数据类型）：BOOLEAN、INT32、INT64、INT96、FLOAT、DOUBLE、BYTE_ARRAY、FIXED_LEN_BYTE_ARRAY</li>\n<li>逻辑数据类型（指导如何转换成基础数据类型进行存储）：<ul>\n<li>字符串类型：STRING、ENUM、UUID</li>\n<li>数字类型：有符号整数，无符号整数 INT(8&#x2F;16&#x2F;32&#x2F;64, true&#x2F;false)</li>\n<li>十进制：DECIMAL</li>\n<li>时间类型：DATE、TIME、TIMESTAMP</li>\n<li>嵌入类型：JSON、BSON、VARIANT</li>\n<li>嵌套类型：LIST（需要三级嵌套），MAP(需要三级嵌套)</li>\n<li>空值</li>\n</ul>\n</li>\n</ul>\n<p>LIST可以用repeated field来表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repeated double speeds;</span><br><span class=\"line\">=========================================================&gt;(parquet格式)</span><br><span class=\"line\">optional group field_id=-1 speeds (List) &#123;</span><br><span class=\"line\">    repeated group field_id=-1 list &#123;</span><br><span class=\"line\">      optional double field_id=-1 element;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>Map可以用包含key-value对且key是required的repeated group来表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repeated group trajectory &#123;</span><br><span class=\"line\">    required timestamp timestamp;</span><br><span class=\"line\">    optional group location &#123;</span><br><span class=\"line\">      required double latitude;  </span><br><span class=\"line\">      required double longitude; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">=========================================================&gt;(parquet格式)</span><br><span class=\"line\">optional group field_id=-1 trajectory (Map) &#123;</span><br><span class=\"line\">    repeated group field_id=-1 key_value &#123;</span><br><span class=\"line\">      required int64 field_id=-1 key (Timestamp);</span><br><span class=\"line\">      optional group field_id=-1 value &#123;</span><br><span class=\"line\">        optional double field_id=-1 latitude;</span><br><span class=\"line\">        optional double field_id=-1 longitude;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-列式存储格式\"><a href=\"#2-2-列式存储格式\" class=\"headerlink\" title=\"2.2 列式存储格式\"></a>2.2 列式存储格式</h2><p>在Parquet格式的存储中，一个schema的树结构有几个叶子节点（叶子节点都是基础数据类型），实际的存储中就会有多少column。 上面SpatialTemporalData的schema的树结构如图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/schema.png\" style=\"width:66%;\"/>\n</div>\n\n<p>这个schema实际存储5列，如表所示:</p>\n<table>\n<thead>\n<tr>\n<th>Column</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>INT32</td>\n</tr>\n<tr>\n<td>speeds</td>\n<td>DOUBLE</td>\n</tr>\n<tr>\n<td>timestamp</td>\n<td>TIMESTAMP</td>\n</tr>\n<tr>\n<td>latitude</td>\n<td>DOUBLE</td>\n</tr>\n<tr>\n<td>longitude</td>\n<td>DOUBLE</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-3-Repetition-and-Definition-Levels\"><a href=\"#2-3-Repetition-and-Definition-Levels\" class=\"headerlink\" title=\"2.3 Repetition and Definition Levels\"></a>2.3 Repetition and Definition Levels</h2><p>Parquet文件采用按列存储的方式，但面对复杂的嵌套结构时，由于嵌套和重复的位置难以确定，恢复原始嵌套结构变得具有一定挑战性。为了解决这一问题，Parquet使用了 <strong>striping and assembly</strong> 算法，通过为每条数据增加 <strong>Repetition Levels</strong> 和 <strong>Definition Levels</strong>，实现对嵌套结构的精准还原。得益于这种设计，任意字段的恢复无需依赖其他字段，同时还支持按照原始嵌套格式对任意字段子集进行重建，大大提升了数据解析的灵活性与效率。以下面表格中的数据为例：</p>\n<table>\n<thead>\n<tr>\n<th><strong>id</strong></th>\n<th><strong>speeds</strong></th>\n<th><strong>trajectory.timestamp</strong></th>\n<th><strong>trajectory.latitude</strong></th>\n<th><strong>trajectory.longitude</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>[12.5, 13.2, 14.1]</td>\n<td>2024-11-21 10:00:00</td>\n<td>40.7128</td>\n<td>-74.0060</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>2024-11-21 10:05:00</td>\n<td>NULL</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>2</td>\n<td>[20.1, 21.3]</td>\n<td>2024-11-21 11:00:00</td>\n<td>34.0522</td>\n<td>-118.2437</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-1-Repetition-Levels\"><a href=\"#2-3-1-Repetition-Levels\" class=\"headerlink\" title=\"2.3.1 Repetition Levels\"></a>2.3.1 Repetition Levels</h3><p><strong>Repetition Level</strong> 用于表示当前值在路径中的重复层级，即该值位于哪个重复字段的结构中。 Repetition Level 专门用来处理重复字段。以 speeds 和 trajectory 为例：</p>\n<ol>\n<li><p><strong>speeds 字段</strong><br>speeds 是一个列表类型字段，包含值 [12.5, 13.2, 14.1]。每个值的 Repetition Level 分别为 0、1 和 1：</p>\n<ul>\n<li>12.5 是列表的第一个值（即列表的起点），因此它的 Repetition Level 为 0。</li>\n<li>后续的值 13.2 和 14.1 都属于同一个列表，表示列表的后续元素，因此它们的 Repetition Level 为 1。</li>\n</ul>\n</li>\n<li><p><strong>trajectory 字段</strong><br>trajectory 是一个 Map 类型，其键为时间戳，值为包含经纬度的结构体。对于每个 Map 键值对：</p>\n<ul>\n<li>第一个键值对（时间戳为 2024-11-21 10:00:00）：这是 Map 的第一个值，因此 Repetition Level 为 0。</li>\n<li>第二个键值对（时间戳为 2024-11-21 10:05:00）：这是同一个 Map 中的第二个值，因此它的 Repetition Level 为 1，表示 Map 的重复部分。虽然纬度和经度的值为空，这些字段的 Repetition Level 依然为 1。</li>\n<li>空值的状态不会影响 Repetition Level，而是通过 Definition Level 来表示。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-3-2-Definition-Levels\"><a href=\"#2-3-2-Definition-Levels\" class=\"headerlink\" title=\"2.3.2 Definition Levels\"></a>2.3.2 Definition Levels</h3><p><strong>Definition Level</strong> 表示路径上有多少可选字段被定义。嵌套数据类型的一个特点是，某些字段（例如可选字段或重复字段）可以为空，或者未被定义。如果一个字段被定义了，那么它的所有父节点也都必须是已定义的。从根节点开始遍历，当某个字段的路径上某个节点为空时，我们记录当前的深度作为该字段的 Definition Level。如果某字段的 Definition Level 达到了它的最大值，就说明该字段是有数据的。对于必须字段（如 required 类型），字段始终是定义的，因此 Definition Level 不需要特别标明。而对于可选字段（如 optional 类型），Definition Level 用于区分字段是未定义（为空）还是有值。在关系型数据中，Definition Level 为 0 表示字段未定义，1 或更高表示字段已定义并可能有值。</p>\n<ol>\n<li><strong>在 speeds 字段中</strong>：<ul>\n<li>speeds 是一个列表字段，其元素是可选的。当列表中某个元素有值时，例如 12.5，它的 Definition Level 为 1，表示该元素被定义且有数据。</li>\n<li>如果 speeds 列表为空，Definition Level 为 0，表示 speeds 未被定义。</li>\n</ul>\n</li>\n<li><strong>在 trajectory 字段中</strong>：<ul>\n<li>trajectory 是一个 Map 类型字段，键为时间戳，值为嵌套的纬度和经度字段。</li>\n<li>当时间戳键值对中，纬度和经度都有值时，例如 latitude &#x3D; 40.7128 和 longitude &#x3D; -74.0060，Definition Level 为 2，表示字段完全定义且有值。</li>\n<li>如果某个时间戳的纬度和经度值为空（例如 timestamp 为 2024-11-21 10:05:00 的键值对），Definition Level 会降为 1，表示字段已定义但没有数据。</li>\n<li>如果整个 trajectory 字段为空，Definition Level 为 0，表示字段未被定义。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-3-3-计算过程\"><a href=\"#2-3-3-计算过程\" class=\"headerlink\" title=\"2.3.3 计算过程\"></a>2.3.3 计算过程</h3><p>以下是第一条和第二条数据的 Repetition Level (R) 和 Definition Level (D) 的计算过程整合：</p>\n<p>对于第一条数据：</p>\n<ul>\n<li><strong>id</strong> 是标量字段，没有嵌套或重复，Repetition Level (R) 固定为 0，Definition Level (D) 固定为 0，表示字段始终定义并有值。</li>\n<li><strong>speeds</strong> 是一个列表，第一个元素 12.5 表示列表的起点，因此 R&#x3D;0，D&#x3D;1；后续的 13.2 和 14.1 属于同一列表，因此 R&#x3D;1，D&#x3D;1，表明字段存在且有值。</li>\n<li><strong>trajectory.timestamp</strong> 是Map的键，第一个键值对2024-11-21 10:00:00是 Map 的起点，R&#x3D;0，D&#x3D;2，表明键和值都定义且非空；第二个键值对2024-11-21 10:05:00是 Map 中的后续键值对，R&#x3D;1，D&#x3D;1，表明键已定义但值为空。</li>\n<li><strong>trajectory.latitude</strong> 和 <strong>trajectory.longitude</strong> 是 Map 值中的嵌套字段，2024-11-21 10:00:00对应的纬度和经度都存在（由于是required字段，与上一层保持相同），因此 R&#x3D;0，D&#x3D;2；2024-11-21 10:05:00的纬度和经度为空，R&#x3D;1，D&#x3D;1，表示字段已定义但无值。</li>\n</ul>\n<p>对于第二条数据：</p>\n<ul>\n<li><strong>id</strong> 是标量字段，与第一条类似，Repetition Level (R) 固定为0，Definition Level (D) 固定为0。</li>\n<li><strong>speeds</strong> 是一个列表，第一个元素 20.1 表示列表的起点，因此 R&#x3D;0，D&#x3D;1；后续的 21.3 属于同一列表，因此 R&#x3D;1，D&#x3D;1，表明字段存在且有值。</li>\n<li><strong>trajectory.timestamp</strong> 是Map的键，只有一个键值对2024-11-21 11:00:00，因此 R&#x3D;0，D&#x3D;2，表明键和值都定义且非空。</li>\n<li><strong>trajectory.latitude</strong> 和 <strong>trajectory.longitude</strong> 是 Map 值中的嵌套字段，2024-11-21 11:00:00对应的纬度和经度都存在，因此 R&#x3D;0，D&#x3D;2，表示字段已定义且有值。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>Column</strong></th>\n<th><strong>Value</strong></th>\n<th><strong>R</strong></th>\n<th><strong>D</strong></th>\n<th><strong>Column</strong></th>\n<th><strong>Value</strong></th>\n<th><strong>R</strong></th>\n<th><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>id</strong></td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td><strong>trajectory.timestamp</strong></td>\n<td>2024-11-21 10:00:00</td>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td></td>\n<td>2</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n<td>2024-11-21 10:05:00</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td><strong>speeds</strong></td>\n<td>12.5</td>\n<td>0</td>\n<td>1</td>\n<td></td>\n<td>2024-11-21 11:00:00</td>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td></td>\n<td>13.2</td>\n<td>1</td>\n<td>1</td>\n<td><strong>trajectory.latitude</strong></td>\n<td>40.7128</td>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td></td>\n<td>14.1</td>\n<td>1</td>\n<td>1</td>\n<td></td>\n<td>NULL</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td>20.1</td>\n<td>0</td>\n<td>1</td>\n<td></td>\n<td>34.0522</td>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td></td>\n<td>21.3</td>\n<td>1</td>\n<td>1</td>\n<td><strong>trajectory.longitude</strong></td>\n<td>-74.0060</td>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>NULL</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>-118.2437</td>\n<td>0</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-4-存储分析\"><a href=\"#2-3-4-存储分析\" class=\"headerlink\" title=\"2.3.4 存储分析\"></a>2.3.4 存储分析</h3><p>在Parquet中，所有字段会被展平为单独的列，每列存储其实际数据，同时附加R和D两列来记录层级结构和字段状态。Parquet并不存储NULL值，而是通过D的值来判断字段是否被定义。例如，Definition Level小于最大值时表示字段为空(NULL)。对于嵌套字段和重复字段（如MAP和LIST），R的值则用于区分新记录与同一结构中的后续值。</p>\n<p>这种设计的优点在于，它可以在保持数据层级关系的同时，避免存储冗余的层级结构信息。同时，由于R和D只需要几位就可以表示字段的状态（如7层结构只需要3bit + 3bit 就能表示R和D），存储开销极小。空字段无需存储实际值，仅通过R和D即可高效表示。这种机制使得Parquet格式在处理嵌套数据时既保持了灵活性，又显著提升了存储和读取效率。</p>\n<h2 id=\"2-4-编码与压缩技术\"><a href=\"#2-4-编码与压缩技术\" class=\"headerlink\" title=\"2.4 编码与压缩技术\"></a>2.4 编码与压缩技术</h2><h3 id=\"2-4-1-编码\"><a href=\"#2-4-1-编码\" class=\"headerlink\" title=\"2.4.1 编码\"></a>2.4.1 编码</h3><p>编码是将数据转换为更紧凑的格式，以减少存储空间或提高计算效率。Parquet 使用了几种常见的编码方式来对数据进行编码，这些编码方式有助于在存储时减少数据的冗余，提高读取性能。</p>\n<ol>\n<li><strong>PLAIN编码</strong>：PLAIN编码是Parquet中最基础的编码方式，它将原始数据直接存储，没有进行任何压缩或变换。该编码方式简单且高效，适用于数据分布均匀的场景，但可能会占用较多存储空间。PLAIN 编码通常用于存储不需要特别优化的字段数据，如简单的整数或字符串。</li>\n<li><strong>DICTIONARY编码</strong>：DICTIONARY编码是一种通过使用字典（映射表）将数据中的重复值替换为字典索引的编码方式。该编码方法适用于有大量重复值的数据类型，比如类别型数据。在Parquet中，数据被分成多个区块，每个区块都会为该区块内的数据生成一个字典。存储时，数据中的重复项会被替换为字典的索引，进而节省存储空间。例如，如果一个字段中有多个相同的值，那么这些值将被映射为字典的索引，存储时只需保存索引而不是重复的值。这种方法能够显著降低存储空间，但需要为每个数据块生成字典，可能会增加读取时的解码开销。</li>\n<li><strong>RLE（Run-Length Encoding）编码</strong>：RLE（Run-Length Encoding）编码是通过记录连续相同值的数量来压缩数据的一种方式。在数据中，若出现连续相同的值，RLE 会记录这些值出现的次数，从而将重复的数据压缩成更小的表示形式。RLE 编码特别适用于数据中存在大量连续相同值的情况。例如，如果一个字段连续出现 100 个相同的数字，那么 RLE 会将其压缩为“值+出现次数”的形式。在 Parquet 中，RLE 编码常用于布尔类型数据或者重复出现的数字类型数据。</li>\n<li><strong>位打包（Bit-Packing）编码</strong>：位打包（Bit-Packing）是一种将多个小数据类型压缩为更小比特数表示的编码方式。该方法通过打包多个值来提高存储效率，通常用于存储较小的数据类型，如整数、布尔值等。Bit-Packing 可以将每个字段中的数据值压缩为最小的比特位数，从而减少存储空间。</li>\n<li><strong>DELTA 编码</strong>：DELTA编码是一种记录数据与其前一个值差异的编码方式。这种方法非常适合存储数值范围比较小且增减变化不大的数据。例如，对于一个增长规律较为平稳的数字序列，DELTA 编码将存储每个数值与前一个数值的差异，而不是存储完整的数值。这样可以显著降低存储空间，特别是对于时间序列数据或连续数据。</li>\n</ol>\n<h3 id=\"2-4-2-编码压缩技术\"><a href=\"#2-4-2-编码压缩技术\" class=\"headerlink\" title=\"2.4.2 编码压缩技术\"></a>2.4.2 编码压缩技术</h3><p>压缩是将数据进一步减少存储空间的技术。Parquet支持多种压缩算法，可以在不牺牲数据质量的情况下，进一步压缩数据以节省存储空间。常见的压缩算法包括Snappy、GZIP、LZO、Brotli等。</p>\n<ol>\n<li>Snappy压缩：Snappy 是 Google 开发的一种压缩算法，具有非常快的压缩和解压缩速度。它的压缩比虽然不如 GZIP，但由于其高效的速度，特别适合大数据处理场景中实时数据处理的需求。Snappy 通常是 Parquet 默认的压缩算法，尤其适用于对速度要求较高的场景。</li>\n<li>GZIP压缩：GZIP是一种较为常见的压缩算法，相较于Snappy，它的压缩比更高，但速度较慢。GZIP压缩适用于对存储空间有较高要求的场景，尤其是当存储成本较高或数据量特别大的时候。GZIP的高压缩比使得它能有效减少存储需求，但解压缩的速度可能成为瓶颈。</li>\n<li>LZO压缩：LZO是一种快速的压缩算法，类似于Snappy，适用于需要快速压缩和解压缩的场景。LZO的压缩比一般不如GZIP，但它的速度非常快，适合于大数据分析中对压缩速度要求较高的应用场景。</li>\n<li>Brotli压缩：Brotli 是由Google开发的一种压缩算法，常用于Web数据传输中的压缩。Brotli的压缩比比GZIP更高，并且其解压速度也较为高效。近年来，Brotli也开始在Parquet中被使用，尤其适用于对存储需求有较高要求的场景。</li>\n<li>Zstandard（ZSTD）压缩：Zstandard（ZSTD）是一种新兴的压缩算法，旨在提供比 GZIP 更高的压缩比和更快的解压速度。ZSTD 兼具了较高的压缩效率和较低的延迟，非常适合需要平衡存储与速度的应用场景。</li>\n</ol>\n<h1 id=\"3-Parquet具体实现\"><a href=\"#3-Parquet具体实现\" class=\"headerlink\" title=\"3. Parquet具体实现\"></a>3. Parquet具体实现</h1><h2 id=\"3-1-Parquet-文件存储格式中的术语\"><a href=\"#3-1-Parquet-文件存储格式中的术语\" class=\"headerlink\" title=\"3.1 Parquet 文件存储格式中的术语\"></a>3.1 Parquet 文件存储格式中的术语</h2><p>在理解 Parquet 文件的存储结构时，熟悉其中关键术语至关重要。以下是 Parquet 中一些核心术语的定义：</p>\n<ul>\n<li><p>**Block (HDFS 块)**：这是 Hadoop 分布式文件系统（HDFS）中数据存储的基本单元，Parquet 文件完全兼容 HDFS 的设计。Block 的大小在 Hadoop 1.x 版本中默认为 64MB，而在 Hadoop 2.x 版本中则增加至 128MB。HDFS 使用 Block 的副本机制来确保数据的冗余和容错能力，从而提高了系统的可靠性和稳定性。</p>\n</li>\n<li><p>**File (文件)**：这是存储在 HDFS 上的一个逻辑实体，包含文件的元数据信息，但其实际数据内容由多个 HDFS Block 保存。</p>\n</li>\n<li><p>**Row Group (行组)**：Parquet 将数据按行划分为多个逻辑上的水平分区。每个 Row Group 包含该组中所有列的列块（Column Chunk），是并行化和 IO 操作的基本单元。这样设计使得每个行组都可以独立解码，便于分布式处理。</p>\n</li>\n<li><p>**Column Chunk (列块)**：指单列数据在一个行组中的物理存储。列块在行组中是逻辑连续的，这种设计允许对列进行有效的压缩和编码，从而提高了存储的利用率。</p>\n</li>\n<li><p>**Page (页面)**：列块被进一步划分为多个 Page，这是 Parquet 文件压缩和编码的最小基本单元。每个列块中可能包含多个类型的 Page，例如数据页面、字典页面等。</p>\n</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/format.png\" style=\"width:66%;\"/>\n</div>\n\n<h2 id=\"3-2-并行化执行的基本单元\"><a href=\"#3-2-并行化执行的基本单元\" class=\"headerlink\" title=\"3.2 并行化执行的基本单元\"></a>3.2 并行化执行的基本单元</h2><p>在 Parquet 文件中，不同层级的数据单元在并行化处理和 IO 操作中发挥不同的作用：</p>\n<ul>\n<li><p><strong>MapReduce 任务划分</strong>：在使用 Hadoop 的 MapReduce 框架处理数据时，通常以 File 或 Row Group 为基本单位来分配任务，即每个任务处理一个完整的文件或者一个行组，从而实现并行化。</p>\n</li>\n<li><p><strong>IO 操作</strong>：Parquet 文件的 IO 操作以 Column Chunk 为基本单位进行。这种设计方式使得可以只读取所需列的数据，减少不必要的磁盘 IO，从而提高读取效率。</p>\n</li>\n<li><p><strong>编码和压缩</strong>：在 Parquet 中，编码和压缩通常以 Page 为单位进行。每个页面可以使用不同的编码方法来提高压缩率，例如使用 RLE（Run Length Encoding）对重复值进行压缩，从而降低存储空间。</p>\n</li>\n</ul>\n<h2 id=\"3-3-Parquet-文件格式\"><a href=\"#3-3-Parquet-文件格式\" class=\"headerlink\" title=\"3.3 Parquet 文件格式\"></a>3.3 Parquet 文件格式</h2><p>Parquet 文件格式具有自解析的特性，文件使用 Thrift 格式定义 schema 以及其他元数据信息。这些元数据信息存储在文件末尾，方便读取时直接访问。</p>\n<p>典型的 Parquet 文件结构如下：</p>\n<ul>\n<li>整个文件被划分为多个行组，每个行组包含所有列的数据块和元数据信息。</li>\n<li>文件的元数据存储在数据部分的最后，包含了所有列块元数据的起始位置。</li>\n</ul>\n<p>这种将元数据存储在文件末尾的设计，使得在写入数据时可以顺序高效地写入文件，同时在读取文件时可以快速获取元数据并定位到相关数据块。</p>\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/metadata.png\" style=\"width:66%;\"/>\n</div>\n\n<h2 id=\"3-4-元数据信息\"><a href=\"#3-4-元数据信息\" class=\"headerlink\" title=\"3.4 元数据信息\"></a>3.4 元数据信息</h2><p>Parquet 文件包含三种不同类型的元数据，每种元数据在不同层级描述文件的内容和结构：</p>\n<ul>\n<li><strong>文件元数据</strong>：描述整个文件的结构和内容，例如行组和列块的位置信息等，是文件级别的数据概览。</li>\n<li><strong>列（块）元数据</strong>：描述单个列块的详细信息，包括该列块的属性、位置和大小。这些元数据使得读取特定列块变得更加高效。</li>\n<li><strong>页面头部元数据</strong>：描述每个页面的具体属性，包括编码方式、压缩方法、页面位置等。这些元数据对于解码和读取页面中的数据至关重要。</li>\n</ul>\n<h2 id=\"3-5-并行读取与列存储的优化\"><a href=\"#3-5-并行读取与列存储的优化\" class=\"headerlink\" title=\"3.5 并行读取与列存储的优化\"></a>3.5 并行读取与列存储的优化</h2><p>Parquet 的设计充分考虑了并行处理和列存储的优势。由于数据是按列存储的，因此可以非常高效地进行列的读取操作。尤其是对于只需要部分列的查询，Parquet 能够显著减少 IO 开销，提升性能。每个行组中的列块在物理上保持连续存储，这样即使是大规模并行读取也可以最大程度减少磁盘寻道时间。</p>\n<h2 id=\"3-6-编码（Encoding）\"><a href=\"#3-6-编码（Encoding）\" class=\"headerlink\" title=\"3.6 编码（Encoding）\"></a>3.6 编码（Encoding）</h2><p>Parquet 支持多种编码方式，以优化数据的压缩和读取效率。细节可以参考官方文档：<a href=\"https://github.com/apache/parquet-format/blob/master/Encodings.md\">Parquet Encodings</a>。通过采用不同的编码方法，Parquet 能够大幅度减少重复值存储，从而节省磁盘空间。</p>\n<h2 id=\"3-7-Column-Chunks-存储与读取\"><a href=\"#3-7-Column-Chunks-存储与读取\" class=\"headerlink\" title=\"3.7 Column Chunks 存储与读取\"></a>3.7 Column Chunks 存储与读取</h2><p>每个 Column Chunk 是由多个 Page 组成的。在读取数据时，Parquet Reader 可以利用页面头部元数据中存储的信息，直接跳过不感兴趣的页面。例如，字典页面与数据页面存储的内容类型不同，Reader 可以根据需求决定是否需要加载某些页面，从而优化查询性能。</p>\n<h2 id=\"3-8-错误处理机制\"><a href=\"#3-8-错误处理机制\" class=\"headerlink\" title=\"3.8 错误处理机制\"></a>3.8 错误处理机制</h2><p>Parquet 文件设计了一系列机制来应对数据损坏的情况，以保证数据的可用性和可靠性：</p>\n<ul>\n<li><strong>文件元数据损坏</strong>：如果整个文件的元数据损坏，通常情况下整个文件会无法读取。</li>\n<li><strong>列元数据损坏</strong>：如果某个列的元数据损坏，只会影响该列块的读取，其他行组中相同列的块仍可正常使用，这种设计能够减少局部损坏对整体数据的影响。</li>\n<li><strong>页面头部损坏</strong>：当页面头部损坏时，该列块中的所有后续页面将无法读取。</li>\n<li><strong>页面数据损坏</strong>：如果某个页面的数据损坏，通常只会导致该页面的数据不可用，其它页面的数据仍然可用。</li>\n</ul>\n<p>较小的行组设置可以更好地抵抗数据损坏，因为损坏只会影响较小的数据范围，而不会影响整个文件。</p>\n<h2 id=\"3-9-推荐的配置参数\"><a href=\"#3-9-推荐的配置参数\" class=\"headerlink\" title=\"3.9 推荐的配置参数\"></a>3.9 推荐的配置参数</h2><p>为了实现最佳的性能和可靠性，Parquet 提供了一些推荐配置：</p>\n<ul>\n<li><p><strong>行组大小（Row group size）</strong>：较大的行组可以使列块变得更大，进而提升顺序 IO 的性能。虽然较大的行组需要更多的内存缓存，但它能够有效减少 IO 操作次数，从而提升性能。Parquet 推荐的行组大小为 512MB 至 1GB。此外，行组最好与 HDFS 的 Block 大小对齐，以减少跨 Block 的 IO 操作。理想的配置是行组大小和 HDFS Block 大小均为 1GB，并保证每个 HDFS 文件对应一个 HDFS Block。</p>\n</li>\n<li><p><strong>数据页大小（Data page size）</strong>：数据页是不可分割的存储单元。较小的数据页允许更精细的随机访问（如单行查找），但会增加 page header 的数量，从而带来空间开销。较大的数据页可以降低页面头部的开销，提升数据解析的效率。Parquet 推荐的数据页大小为 8KB，以在性能与空间利用率之间取得平衡。</p>\n</li>\n</ul>\n<p>总结来看，Parquet 文件格式通过行组、列块、页面三级结构，结合丰富的元数据信息和多种编码方式，达到了高效的数据存储和读取性能。其列式存储特性使得数据的压缩率大幅提高，并能高效支持大规模的并行查询。对于需要处理海量数据的场景，Parquet 是一种高效而可靠的数据存储格式。</p>\n<h1 id=\"4-Python使用Parquet\"><a href=\"#4-Python使用Parquet\" class=\"headerlink\" title=\"4. Python使用Parquet\"></a>4. Python使用Parquet</h1><h2 id=\"4-1-安装依赖并导入\"><a href=\"#4-1-安装依赖并导入\" class=\"headerlink\" title=\"4.1 安装依赖并导入\"></a>4.1 安装依赖并导入</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pyarrow pandas</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pyarrow <span class=\"keyword\">as</span> pa</span><br><span class=\"line\"><span class=\"keyword\">import</span> pyarrow.parquet <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2-定义schema\"><a href=\"#4-2-定义schema\" class=\"headerlink\" title=\"4.2 定义schema\"></a>4.2 定义schema</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schema = pa.schema([</span><br><span class=\"line\">    (<span class=\"string\">&quot;id&quot;</span>, pa.int32()),</span><br><span class=\"line\">    (<span class=\"string\">&quot;speeds&quot;</span>, pa.list_(pa.float64())),</span><br><span class=\"line\">    (<span class=\"string\">&quot;trajectory&quot;</span>, pa.map_(</span><br><span class=\"line\">        pa.timestamp(<span class=\"string\">&#x27;ms&#x27;</span>),  </span><br><span class=\"line\">        pa.struct([   </span><br><span class=\"line\">            (<span class=\"string\">&quot;latitude&quot;</span>, pa.float64()),</span><br><span class=\"line\">            (<span class=\"string\">&quot;longitude&quot;</span>, pa.float64())</span><br><span class=\"line\">        ])</span><br><span class=\"line\">    ))</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-3-导入数据\"><a href=\"#4-3-导入数据\" class=\"headerlink\" title=\"4.3 导入数据\"></a>4.3 导入数据</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;id&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;speeds&quot;</span>: [<span class=\"number\">12.5</span>, <span class=\"number\">13.2</span>, <span class=\"number\">14.1</span>],</span><br><span class=\"line\">        <span class=\"string\">&quot;trajectory&quot;</span>: &#123;</span><br><span class=\"line\">            datetime(<span class=\"number\">2024</span>, <span class=\"number\">11</span>, <span class=\"number\">21</span>, <span class=\"number\">10</span>, <span class=\"number\">0</span>): &#123;<span class=\"string\">&quot;latitude&quot;</span>: <span class=\"number\">40.7128</span>, <span class=\"string\">&quot;longitude&quot;</span>: -<span class=\"number\">74.0060</span>&#125;,</span><br><span class=\"line\">            datetime(<span class=\"number\">2024</span>, <span class=\"number\">11</span>, <span class=\"number\">21</span>, <span class=\"number\">10</span>, <span class=\"number\">5</span>): <span class=\"literal\">None</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;id&quot;</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;speeds&quot;</span>: [<span class=\"number\">20.1</span>, <span class=\"number\">21.3</span>],</span><br><span class=\"line\">        <span class=\"string\">&quot;trajectory&quot;</span>: &#123;</span><br><span class=\"line\">            datetime(<span class=\"number\">2024</span>, <span class=\"number\">11</span>, <span class=\"number\">21</span>, <span class=\"number\">11</span>, <span class=\"number\">0</span>): &#123;<span class=\"string\">&quot;latitude&quot;</span>: <span class=\"number\">34.0522</span>, <span class=\"string\">&quot;longitude&quot;</span>: -<span class=\"number\">118.2437</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-4-生成parquet文件\"><a href=\"#4-4-生成parquet文件\" class=\"headerlink\" title=\"4.4 生成parquet文件\"></a>4.4 生成parquet文件</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compression_method = <span class=\"string\">&#x27;gzip&#x27;</span> <span class=\"comment\">#(snappy、lzo、brotli ...)</span></span><br><span class=\"line\">table = pa.Table.from_pandas(df, schema=schema)</span><br><span class=\"line\">pq.write_table(table, <span class=\"string\">&quot;example.parquet&quot;</span>, compression_method)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-4读取parquet文件并且查看格式信息\"><a href=\"#4-4读取parquet文件并且查看格式信息\" class=\"headerlink\" title=\"4.4读取parquet文件并且查看格式信息\"></a>4.4读取parquet文件并且查看格式信息</h2><h3 id=\"4-4-1-读取parquet文件\"><a href=\"#4-4-1-读取parquet文件\" class=\"headerlink\" title=\"4.4.1 读取parquet文件\"></a>4.4.1 读取parquet文件</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read_table = pq.read_table(<span class=\"string\">&quot;exmaple.parquet&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(read_table.to_pandas())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  id        speeds                                         trajectory</span><br><span class=\"line\">0   1  [45.5, 60.2]  [&#123;&#x27;key&#x27;: 2024-11-21 10:30:00, &#x27;value&#x27;: &#123;&#x27;latit...</span><br><span class=\"line\">1   2  [35.2, 50.0]  [&#123;&#x27;key&#x27;: 2024-11-21 11:00:00, &#x27;value&#x27;: &#123;&#x27;latit...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-2-查看schame-元信息\"><a href=\"#4-4-2-查看schame-元信息\" class=\"headerlink\" title=\"4.4.2 查看schame&amp;元信息\"></a>4.4.2 查看schame&amp;元信息</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parquet_file = pq.ParquetFile(<span class=\"string\">&quot;example&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;元信息：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(parquet_file.metadata)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nSchema：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(parquet_file.schema)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 元信息：</span><br><span class=\"line\">&lt;pyarrow._parquet.FileMetaData object at 0x000002019E93A980&gt;</span><br><span class=\"line\">  created_by: parquet-cpp-arrow version 18.0.0-SNAPSHOT</span><br><span class=\"line\">  num_columns: 5</span><br><span class=\"line\">  num_rows: 2</span><br><span class=\"line\">  num_row_groups: 1</span><br><span class=\"line\">  format_version: 2.6</span><br><span class=\"line\">  serialized_size: 3014</span><br><span class=\"line\"></span><br><span class=\"line\">Schema：</span><br><span class=\"line\">&lt;pyarrow._parquet.ParquetSchema object at 0x000002019E9F0A40&gt;</span><br><span class=\"line\">required group field_id=-1 schema &#123;</span><br><span class=\"line\">  optional int32 field_id=-1 id;</span><br><span class=\"line\">  optional group field_id=-1 speeds (List) &#123;</span><br><span class=\"line\">    repeated group field_id=-1 list &#123;</span><br><span class=\"line\">      optional double field_id=-1 element;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  optional group field_id=-1 trajectory (Map) &#123;</span><br><span class=\"line\">    repeated group field_id=-1 key_value &#123;</span><br><span class=\"line\">      required int64 field_id=-1 key (Timestamp(isAdjustedToUTC=false, timeUnit=milliseconds, is_from_converted_type=false, force_set_converted_type=false));</span><br><span class=\"line\">      optional group field_id=-1 value &#123;</span><br><span class=\"line\">        optional double field_id=-1 latitude;</span><br><span class=\"line\">        optional double field_id=-1 longitude;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-3-查看列信息\"><a href=\"#4-4-3-查看列信息\" class=\"headerlink\" title=\"4.4.3 查看列信息\"></a>4.4.3 查看列信息</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row_group = parquet_file.metadata.row_group(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> col_idx <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(parquet_file.metadata.num_columns):</span><br><span class=\"line\">    column = row_group.column(col_idx)</span><br><span class=\"line\">    column_name = parquet_file.schema.column(col_idx).name</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;列 <span class=\"subst\">&#123;col_idx&#125;</span> (<span class=\"subst\">&#123;column_name&#125;</span>) 信息：&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  总值数量：<span class=\"subst\">&#123;column.num_values&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  压缩大小：<span class=\"subst\">&#123;column.total_compressed_size&#125;</span> 字节&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  未压缩大小：<span class=\"subst\">&#123;column.total_uncompressed_size&#125;</span> 字节&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  最大值：<span class=\"subst\">&#123;column.statistics.<span class=\"built_in\">max</span> <span class=\"keyword\">if</span> column.statistics <span class=\"keyword\">else</span> <span class=\"string\">&#x27;无统计信息&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  最小值：<span class=\"subst\">&#123;column.statistics.<span class=\"built_in\">min</span> <span class=\"keyword\">if</span> column.statistics <span class=\"keyword\">else</span> <span class=\"string\">&#x27;无统计信息&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  空值数量：<span class=\"subst\">&#123;column.statistics.null_count <span class=\"keyword\">if</span> column.statistics <span class=\"keyword\">else</span> <span class=\"string\">&#x27;无统计信息&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  列 0 (id) 信息：</span><br><span class=\"line\">  总值数量：2</span><br><span class=\"line\">  压缩大小：80 字节</span><br><span class=\"line\">  未压缩大小：76 字节</span><br><span class=\"line\">  最大值：2</span><br><span class=\"line\">  最小值：1</span><br><span class=\"line\">  空值数量：0</span><br><span class=\"line\">---</span><br><span class=\"line\">列 1 (element) 信息：</span><br><span class=\"line\">  总值数量：5</span><br><span class=\"line\">  压缩大小：130 字节</span><br><span class=\"line\">  未压缩大小：132 字节</span><br><span class=\"line\">  最大值：21.3</span><br><span class=\"line\">  最小值：12.5</span><br><span class=\"line\">  空值数量：0</span><br><span class=\"line\">---</span><br><span class=\"line\">列 2 (key) 信息：</span><br><span class=\"line\">  总值数量：3</span><br><span class=\"line\">  压缩大小：119 字节</span><br><span class=\"line\">  未压缩大小：115 字节</span><br><span class=\"line\">  最大值：2024-11-21 11:00:00</span><br><span class=\"line\">  最小值：2024-11-21 10:00:00</span><br><span class=\"line\">  空值数量：0</span><br><span class=\"line\">---</span><br><span class=\"line\">列 3 (latitude) 信息：</span><br><span class=\"line\">  总值数量：3</span><br><span class=\"line\">  压缩大小：119 字节</span><br><span class=\"line\">  未压缩大小：115 字节</span><br><span class=\"line\">  最大值：40.7138</span><br><span class=\"line\">  最小值：34.0522</span><br><span class=\"line\">  空值数量：0</span><br><span class=\"line\">---</span><br><span class=\"line\">列 4 (longitude) 信息：</span><br><span class=\"line\">  总值数量：3</span><br><span class=\"line\">  压缩大小：119 字节</span><br><span class=\"line\">  未压缩大小：115 字节</span><br><span class=\"line\">  最大值：-74.006</span><br><span class=\"line\">  最小值：-118.2437</span><br><span class=\"line\">  空值数量：0</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-4-查看列编码方式\"><a href=\"#4-4-4-查看列编码方式\" class=\"headerlink\" title=\"4.4.4 查看列编码方式\"></a>4.4.4 查看列编码方式</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> col_idx <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(parquet_file.metadata.num_columns):</span><br><span class=\"line\">    column_encoding = parquet_file.metadata.row_group(<span class=\"number\">0</span>).column(col_idx).encodings</span><br><span class=\"line\">    column_name = parquet_file.schema.column(col_idx).name</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;列 <span class=\"subst\">&#123;col_idx&#125;</span> (<span class=\"subst\">&#123;column_name&#125;</span>) 编码方式：&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  Encodings: <span class=\"subst\">&#123;column_encoding&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---&quot;</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">列 0 (id) 编码方式：</span><br><span class=\"line\">  Encodings: (&#x27;PLAIN&#x27;, &#x27;RLE&#x27;, &#x27;RLE_DICTIONARY&#x27;)</span><br><span class=\"line\">---</span><br><span class=\"line\">列 1 (element) 编码方式：</span><br><span class=\"line\">  Encodings: (&#x27;PLAIN&#x27;, &#x27;RLE&#x27;, &#x27;RLE_DICTIONARY&#x27;)</span><br><span class=\"line\">---</span><br><span class=\"line\">列 2 (key) 编码方式：</span><br><span class=\"line\">  Encodings: (&#x27;PLAIN&#x27;, &#x27;RLE&#x27;, &#x27;RLE_DICTIONARY&#x27;)</span><br><span class=\"line\">---</span><br><span class=\"line\">列 3 (latitude) 编码方式：</span><br><span class=\"line\">  Encodings: (&#x27;PLAIN&#x27;, &#x27;RLE&#x27;, &#x27;RLE_DICTIONARY&#x27;)</span><br><span class=\"line\">---</span><br><span class=\"line\">列 4 (longitude) 编码方式：</span><br><span class=\"line\">  Encodings: (&#x27;PLAIN&#x27;, &#x27;RLE&#x27;, &#x27;RLE_DICTIONARY&#x27;)</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><p>本文详细介绍了 Apache Parquet 格式的原理与实践，重点讲解了其列式存储结构、嵌套数据支持、编码与压缩技术、以及如何在 Python 中使用 Parquet 文件。Parquet 的设计充分利用了列式存储的优势，特别是在大数据分析场景中，它能够显著提高查询效率并有效节省存储空间。</p>\n<ol>\n<li><p><strong>列式存储优势</strong>：Parquet 的列式存储方式使得在进行数据分析时，可以只读取所需的列，减少了不必要的磁盘 I&#x2F;O 操作。此外，列式存储能高效地压缩数据，特别是对于重复性高的数据，能够显著减少存储空间的占用。</p>\n</li>\n<li><p><strong>复杂嵌套结构支持</strong>：通过使用 Repetition Levels 和 Definition Levels，Parquet 能够高效处理复杂的嵌套数据结构，例如 List 和 Map。这种设计让 Parquet 格式在处理包含多个嵌套字段的复杂数据时，保持高效且灵活。</p>\n</li>\n<li><p><strong>编码与压缩技术</strong>：Parquet 支持多种编码方式（如 PLAIN、DICTIONARY、RLE 编码等）和压缩算法（如 Snappy、GZIP、LZO 等）。这些技术帮助优化存储空间并提升数据读取性能。在不同的场景下，用户可以选择适合的编码和压缩方法，以平衡存储与速度的需求。</p>\n</li>\n<li><p><strong>Python 使用 Parquet</strong>：通过 <code>pyarrow</code> 库，Python 用户能够轻松地创建、读取和操作 Parquet 文件。示例代码展示了如何定义 Parquet 文件的 schema、将数据导入并生成 Parquet 文件，以及如何读取 Parquet 文件并查看其元数据和编码信息。</p>\n</li>\n<li><p><strong>性能优化</strong>：Parquet 的设计考虑了并行处理，支持高效的列读取操作，这对于大规模数据处理非常重要。它通过将数据划分为行组（Row Groups）、列块（Column Chunks）和页面（Pages），使得分布式计算框架如 Hadoop 和 Spark 能够高效地处理数据。</p>\n</li>\n</ol>\n<p>总的来说，Parquet 是一种功能强大的数据存储格式，它结合了列式存储的优势与高效的压缩、编码技术，特别适合用于大数据分析和大规模分布式计算环境中。</p>\n","cover_type":"img","excerpt":"","more":"<p>Apache Parquet 是一种高效的列式存储格式，其设计初衷是优化大规模数据处理的性能与存储效率。在大数据领域，随着数据规模的迅速增长，如何高效地存储、读取和处理数据已成为关键问题。作为 Apache 软件基金会支持的开源项目，Parquet 凭借卓越的数据压缩率和快速查询能力，被广泛应用于各类大数据处理场景。本文旨在从理论与实践的双重视角，系统分析 Apache Parquet 的设计理念、核心架构与技术实现，特别是其在处理复杂嵌套数据结构方面的独特优势，期望为研究者和开发者提供深入的理解与指导。</p>\n<hr>\n<h1 id=\"1-基础概念\"><a href=\"#1-基础概念\" class=\"headerlink\" title=\"1. 基础概念\"></a>1. 基础概念</h1><h2 id=\"1-1-列式存储-VS-行式存储\"><a href=\"#1-1-列式存储-VS-行式存储\" class=\"headerlink\" title=\"1.1 列式存储 VS 行式存储\"></a>1.1 列式存储 VS 行式存储</h2><p><strong>行式存储</strong>：行式存储是将一行数据的所有字段连续存储在一起。例如，对于下表中的数据：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>latitude</th>\n<th>longitude</th>\n<th>timestamp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>23</td>\n<td>106.551556</td>\n<td>29.563761</td>\n<td>1732118400</td>\n</tr>\n<tr>\n<td>46</td>\n<td>106.480989</td>\n<td>29.600298</td>\n<td>1732161600</td>\n</tr>\n<tr>\n<td>99</td>\n<td>106.512051</td>\n<td>29.583541</td>\n<td>1732183200</td>\n</tr>\n</tbody></table>\n<p>在行式存储中，数据会按照以下方式存储：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">23, 106.551556, 29.563761, 1732118400</span><br><span class=\"line\">46, 106.480989, 29.600298, 1732161600</span><br><span class=\"line\">99, 106.512051, 29.583541, 1732183200</span><br></pre></td></tr></table></figure>\n\n<p>每一行的数据被紧密地存储在一起，这样的存储方式便于对单行数据的增、删、改、查操作。 在行式存储模式下，整行数据的存取非常高效，尤其是在需要获取或修改完整的一行数据时，能够显著提高访问效率。行式存储的优点：</p>\n<ol>\n<li><strong>快速定位整行数据</strong>：行式存储能够快速定位到某一行的数据。例如，当查询id&#x3D;46的数据时，只需从存储中直接读取这一行，所有字段都能一次性高效返回。</li>\n<li><strong>事务操作支持好</strong>：行式存储非常适合高频的增删改操作，例如修改id&#x3D;23这一行的timestamp值。这种操作只需要定位到该行并进行更新，整体效率非常高。</li>\n</ol>\n<p>如果需要查询或更新id&#x3D;46的所有数据，行式存储可以快速定位到46, 106.480989, 29.600298, 1732161600&#96; 这一整行数据，并进行操作，而无需访问其他数据，因而效率非常高。行式存储特别适合 OLTP（在线事务处理）场景，电商系统、银行系统等需要频繁处理单条记录的增删改操作的应用中，行式存储表现尤为出色。</p>\n<p><strong>列式存储</strong>：与行式存储不同，列式存储将同一列的数据连续存储在一起。对于上面的示例表格，列式存储方式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id:        23, 46, 99</span><br><span class=\"line\">latitude:  106.551556, 106.480989, 106.512051</span><br><span class=\"line\">longitude: 29.563761, 29.600298, 29.583541</span><br><span class=\"line\">timestamp: 1732118400, 1732161600, 1732183200</span><br></pre></td></tr></table></figure>\n\n<p>在这种存储模式下，每列的数据在物理存储中是连续存放的，列与列之间的数据相互独立。列式存储更适合对某些列进行查询，例如在大数据分析中仅需要查询latitude和longitude，而无需加载其他字段。列式存储的优点：</p>\n<ol>\n<li><strong>按列查询性能高</strong>：在数据分析场景中，查询操作往往只涉及少数列，例如筛选latitude接近106.5的数据。在列式存储中，只需读取 latitude列即可，这显著减少了 I&#x2F;O 操作和内存占用，提高了查询效率。</li>\n<li><strong>压缩效果好</strong>：由于同一列的数据类型相同且分布相似，列式存储能够实现高效压缩。例如，timestamp列的值有一定规律性，这样的数据在列式存储中可以被压缩得非常紧凑，从而节省存储空间并加速处理。</li>\n</ol>\n<p>如果需要查找所有记录的latitude，列式存储只需要读取106.551556, 106.480989, 106.512051这一列的数据，跳过其他列的数据，减少了读取不必要数据的开销，这对于大规模数据分析非常高效。 列式存储非常适合OLAP（在线分析处理）场景，尤其在数据仓库、大规模数据分析等需要对大量数据进行聚合、过滤和统计计算的应用中，列式存储能够显著提高查询效率。</p>\n<h1 id=\"2-Parquet详解\"><a href=\"#2-Parquet详解\" class=\"headerlink\" title=\"2. Parquet详解\"></a>2. Parquet详解</h1><h2 id=\"2-1-数据模型\"><a href=\"#2-1-数据模型\" class=\"headerlink\" title=\"2.1 数据模型\"></a>2.1 数据模型</h2><p>Parquet采用了一个类似Google Protobuf的协议来描述存储数据的schema，以下面这个schema为例介绍Parquet的数据模型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message SpatialTemporalData &#123;</span><br><span class=\"line\">  required int32 id;</span><br><span class=\"line\">  repeated double speeds;</span><br><span class=\"line\">  repeated group trajectory &#123;</span><br><span class=\"line\">    required timestamp timestamp;</span><br><span class=\"line\">    optional group location &#123;</span><br><span class=\"line\">      required double latitude;  </span><br><span class=\"line\">      required double longitude; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个schema中，每条记录代表一条轨迹。每条记录中有且仅有一个id，每个id可以对应0个或多个speeds和trajectory。每个trajectory必须包含一个timestamp，location字段则为可选字段。每个location必须包含唯一的latitude和longitude。在 schema的顶层是message，它可以包含多个字段。每个字段具有三个属性：<strong>重复性</strong>（repetition）、<strong>类型</strong>（type）和 <strong>名字</strong>（name）。</p>\n<p>字段的重复性包含三种：</p>\n<ul>\n<li>required：有且只有一次</li>\n<li>optional：0次或1次</li>\n<li>repeated：0次或多次</li>\n</ul>\n<p>字段的类型包括：</p>\n<ul>\n<li>基础数据类型（物理上只存储基础数据类型）：BOOLEAN、INT32、INT64、INT96、FLOAT、DOUBLE、BYTE_ARRAY、FIXED_LEN_BYTE_ARRAY</li>\n<li>逻辑数据类型（指导如何转换成基础数据类型进行存储）：<ul>\n<li>字符串类型：STRING、ENUM、UUID</li>\n<li>数字类型：有符号整数，无符号整数 INT(8&#x2F;16&#x2F;32&#x2F;64, true&#x2F;false)</li>\n<li>十进制：DECIMAL</li>\n<li>时间类型：DATE、TIME、TIMESTAMP</li>\n<li>嵌入类型：JSON、BSON、VARIANT</li>\n<li>嵌套类型：LIST（需要三级嵌套），MAP(需要三级嵌套)</li>\n<li>空值</li>\n</ul>\n</li>\n</ul>\n<p>LIST可以用repeated field来表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repeated double speeds;</span><br><span class=\"line\">=========================================================&gt;(parquet格式)</span><br><span class=\"line\">optional group field_id=-1 speeds (List) &#123;</span><br><span class=\"line\">    repeated group field_id=-1 list &#123;</span><br><span class=\"line\">      optional double field_id=-1 element;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>Map可以用包含key-value对且key是required的repeated group来表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repeated group trajectory &#123;</span><br><span class=\"line\">    required timestamp timestamp;</span><br><span class=\"line\">    optional group location &#123;</span><br><span class=\"line\">      required double latitude;  </span><br><span class=\"line\">      required double longitude; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">=========================================================&gt;(parquet格式)</span><br><span class=\"line\">optional group field_id=-1 trajectory (Map) &#123;</span><br><span class=\"line\">    repeated group field_id=-1 key_value &#123;</span><br><span class=\"line\">      required int64 field_id=-1 key (Timestamp);</span><br><span class=\"line\">      optional group field_id=-1 value &#123;</span><br><span class=\"line\">        optional double field_id=-1 latitude;</span><br><span class=\"line\">        optional double field_id=-1 longitude;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-列式存储格式\"><a href=\"#2-2-列式存储格式\" class=\"headerlink\" title=\"2.2 列式存储格式\"></a>2.2 列式存储格式</h2><p>在Parquet格式的存储中，一个schema的树结构有几个叶子节点（叶子节点都是基础数据类型），实际的存储中就会有多少column。 上面SpatialTemporalData的schema的树结构如图所示：</p>\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/schema.png\" style=\"width:66%;\"/>\n</div>\n\n<p>这个schema实际存储5列，如表所示:</p>\n<table>\n<thead>\n<tr>\n<th>Column</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>INT32</td>\n</tr>\n<tr>\n<td>speeds</td>\n<td>DOUBLE</td>\n</tr>\n<tr>\n<td>timestamp</td>\n<td>TIMESTAMP</td>\n</tr>\n<tr>\n<td>latitude</td>\n<td>DOUBLE</td>\n</tr>\n<tr>\n<td>longitude</td>\n<td>DOUBLE</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-3-Repetition-and-Definition-Levels\"><a href=\"#2-3-Repetition-and-Definition-Levels\" class=\"headerlink\" title=\"2.3 Repetition and Definition Levels\"></a>2.3 Repetition and Definition Levels</h2><p>Parquet文件采用按列存储的方式，但面对复杂的嵌套结构时，由于嵌套和重复的位置难以确定，恢复原始嵌套结构变得具有一定挑战性。为了解决这一问题，Parquet使用了 <strong>striping and assembly</strong> 算法，通过为每条数据增加 <strong>Repetition Levels</strong> 和 <strong>Definition Levels</strong>，实现对嵌套结构的精准还原。得益于这种设计，任意字段的恢复无需依赖其他字段，同时还支持按照原始嵌套格式对任意字段子集进行重建，大大提升了数据解析的灵活性与效率。以下面表格中的数据为例：</p>\n<table>\n<thead>\n<tr>\n<th><strong>id</strong></th>\n<th><strong>speeds</strong></th>\n<th><strong>trajectory.timestamp</strong></th>\n<th><strong>trajectory.latitude</strong></th>\n<th><strong>trajectory.longitude</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>[12.5, 13.2, 14.1]</td>\n<td>2024-11-21 10:00:00</td>\n<td>40.7128</td>\n<td>-74.0060</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>2024-11-21 10:05:00</td>\n<td>NULL</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>2</td>\n<td>[20.1, 21.3]</td>\n<td>2024-11-21 11:00:00</td>\n<td>34.0522</td>\n<td>-118.2437</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-1-Repetition-Levels\"><a href=\"#2-3-1-Repetition-Levels\" class=\"headerlink\" title=\"2.3.1 Repetition Levels\"></a>2.3.1 Repetition Levels</h3><p><strong>Repetition Level</strong> 用于表示当前值在路径中的重复层级，即该值位于哪个重复字段的结构中。 Repetition Level 专门用来处理重复字段。以 speeds 和 trajectory 为例：</p>\n<ol>\n<li><p><strong>speeds 字段</strong><br>speeds 是一个列表类型字段，包含值 [12.5, 13.2, 14.1]。每个值的 Repetition Level 分别为 0、1 和 1：</p>\n<ul>\n<li>12.5 是列表的第一个值（即列表的起点），因此它的 Repetition Level 为 0。</li>\n<li>后续的值 13.2 和 14.1 都属于同一个列表，表示列表的后续元素，因此它们的 Repetition Level 为 1。</li>\n</ul>\n</li>\n<li><p><strong>trajectory 字段</strong><br>trajectory 是一个 Map 类型，其键为时间戳，值为包含经纬度的结构体。对于每个 Map 键值对：</p>\n<ul>\n<li>第一个键值对（时间戳为 2024-11-21 10:00:00）：这是 Map 的第一个值，因此 Repetition Level 为 0。</li>\n<li>第二个键值对（时间戳为 2024-11-21 10:05:00）：这是同一个 Map 中的第二个值，因此它的 Repetition Level 为 1，表示 Map 的重复部分。虽然纬度和经度的值为空，这些字段的 Repetition Level 依然为 1。</li>\n<li>空值的状态不会影响 Repetition Level，而是通过 Definition Level 来表示。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-3-2-Definition-Levels\"><a href=\"#2-3-2-Definition-Levels\" class=\"headerlink\" title=\"2.3.2 Definition Levels\"></a>2.3.2 Definition Levels</h3><p><strong>Definition Level</strong> 表示路径上有多少可选字段被定义。嵌套数据类型的一个特点是，某些字段（例如可选字段或重复字段）可以为空，或者未被定义。如果一个字段被定义了，那么它的所有父节点也都必须是已定义的。从根节点开始遍历，当某个字段的路径上某个节点为空时，我们记录当前的深度作为该字段的 Definition Level。如果某字段的 Definition Level 达到了它的最大值，就说明该字段是有数据的。对于必须字段（如 required 类型），字段始终是定义的，因此 Definition Level 不需要特别标明。而对于可选字段（如 optional 类型），Definition Level 用于区分字段是未定义（为空）还是有值。在关系型数据中，Definition Level 为 0 表示字段未定义，1 或更高表示字段已定义并可能有值。</p>\n<ol>\n<li><strong>在 speeds 字段中</strong>：<ul>\n<li>speeds 是一个列表字段，其元素是可选的。当列表中某个元素有值时，例如 12.5，它的 Definition Level 为 1，表示该元素被定义且有数据。</li>\n<li>如果 speeds 列表为空，Definition Level 为 0，表示 speeds 未被定义。</li>\n</ul>\n</li>\n<li><strong>在 trajectory 字段中</strong>：<ul>\n<li>trajectory 是一个 Map 类型字段，键为时间戳，值为嵌套的纬度和经度字段。</li>\n<li>当时间戳键值对中，纬度和经度都有值时，例如 latitude &#x3D; 40.7128 和 longitude &#x3D; -74.0060，Definition Level 为 2，表示字段完全定义且有值。</li>\n<li>如果某个时间戳的纬度和经度值为空（例如 timestamp 为 2024-11-21 10:05:00 的键值对），Definition Level 会降为 1，表示字段已定义但没有数据。</li>\n<li>如果整个 trajectory 字段为空，Definition Level 为 0，表示字段未被定义。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-3-3-计算过程\"><a href=\"#2-3-3-计算过程\" class=\"headerlink\" title=\"2.3.3 计算过程\"></a>2.3.3 计算过程</h3><p>以下是第一条和第二条数据的 Repetition Level (R) 和 Definition Level (D) 的计算过程整合：</p>\n<p>对于第一条数据：</p>\n<ul>\n<li><strong>id</strong> 是标量字段，没有嵌套或重复，Repetition Level (R) 固定为 0，Definition Level (D) 固定为 0，表示字段始终定义并有值。</li>\n<li><strong>speeds</strong> 是一个列表，第一个元素 12.5 表示列表的起点，因此 R&#x3D;0，D&#x3D;1；后续的 13.2 和 14.1 属于同一列表，因此 R&#x3D;1，D&#x3D;1，表明字段存在且有值。</li>\n<li><strong>trajectory.timestamp</strong> 是Map的键，第一个键值对2024-11-21 10:00:00是 Map 的起点，R&#x3D;0，D&#x3D;2，表明键和值都定义且非空；第二个键值对2024-11-21 10:05:00是 Map 中的后续键值对，R&#x3D;1，D&#x3D;1，表明键已定义但值为空。</li>\n<li><strong>trajectory.latitude</strong> 和 <strong>trajectory.longitude</strong> 是 Map 值中的嵌套字段，2024-11-21 10:00:00对应的纬度和经度都存在（由于是required字段，与上一层保持相同），因此 R&#x3D;0，D&#x3D;2；2024-11-21 10:05:00的纬度和经度为空，R&#x3D;1，D&#x3D;1，表示字段已定义但无值。</li>\n</ul>\n<p>对于第二条数据：</p>\n<ul>\n<li><strong>id</strong> 是标量字段，与第一条类似，Repetition Level (R) 固定为0，Definition Level (D) 固定为0。</li>\n<li><strong>speeds</strong> 是一个列表，第一个元素 20.1 表示列表的起点，因此 R&#x3D;0，D&#x3D;1；后续的 21.3 属于同一列表，因此 R&#x3D;1，D&#x3D;1，表明字段存在且有值。</li>\n<li><strong>trajectory.timestamp</strong> 是Map的键，只有一个键值对2024-11-21 11:00:00，因此 R&#x3D;0，D&#x3D;2，表明键和值都定义且非空。</li>\n<li><strong>trajectory.latitude</strong> 和 <strong>trajectory.longitude</strong> 是 Map 值中的嵌套字段，2024-11-21 11:00:00对应的纬度和经度都存在，因此 R&#x3D;0，D&#x3D;2，表示字段已定义且有值。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>Column</strong></th>\n<th><strong>Value</strong></th>\n<th><strong>R</strong></th>\n<th><strong>D</strong></th>\n<th><strong>Column</strong></th>\n<th><strong>Value</strong></th>\n<th><strong>R</strong></th>\n<th><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>id</strong></td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td><strong>trajectory.timestamp</strong></td>\n<td>2024-11-21 10:00:00</td>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td></td>\n<td>2</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n<td>2024-11-21 10:05:00</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td><strong>speeds</strong></td>\n<td>12.5</td>\n<td>0</td>\n<td>1</td>\n<td></td>\n<td>2024-11-21 11:00:00</td>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td></td>\n<td>13.2</td>\n<td>1</td>\n<td>1</td>\n<td><strong>trajectory.latitude</strong></td>\n<td>40.7128</td>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td></td>\n<td>14.1</td>\n<td>1</td>\n<td>1</td>\n<td></td>\n<td>NULL</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td>20.1</td>\n<td>0</td>\n<td>1</td>\n<td></td>\n<td>34.0522</td>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td></td>\n<td>21.3</td>\n<td>1</td>\n<td>1</td>\n<td><strong>trajectory.longitude</strong></td>\n<td>-74.0060</td>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>NULL</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>-118.2437</td>\n<td>0</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-4-存储分析\"><a href=\"#2-3-4-存储分析\" class=\"headerlink\" title=\"2.3.4 存储分析\"></a>2.3.4 存储分析</h3><p>在Parquet中，所有字段会被展平为单独的列，每列存储其实际数据，同时附加R和D两列来记录层级结构和字段状态。Parquet并不存储NULL值，而是通过D的值来判断字段是否被定义。例如，Definition Level小于最大值时表示字段为空(NULL)。对于嵌套字段和重复字段（如MAP和LIST），R的值则用于区分新记录与同一结构中的后续值。</p>\n<p>这种设计的优点在于，它可以在保持数据层级关系的同时，避免存储冗余的层级结构信息。同时，由于R和D只需要几位就可以表示字段的状态（如7层结构只需要3bit + 3bit 就能表示R和D），存储开销极小。空字段无需存储实际值，仅通过R和D即可高效表示。这种机制使得Parquet格式在处理嵌套数据时既保持了灵活性，又显著提升了存储和读取效率。</p>\n<h2 id=\"2-4-编码与压缩技术\"><a href=\"#2-4-编码与压缩技术\" class=\"headerlink\" title=\"2.4 编码与压缩技术\"></a>2.4 编码与压缩技术</h2><h3 id=\"2-4-1-编码\"><a href=\"#2-4-1-编码\" class=\"headerlink\" title=\"2.4.1 编码\"></a>2.4.1 编码</h3><p>编码是将数据转换为更紧凑的格式，以减少存储空间或提高计算效率。Parquet 使用了几种常见的编码方式来对数据进行编码，这些编码方式有助于在存储时减少数据的冗余，提高读取性能。</p>\n<ol>\n<li><strong>PLAIN编码</strong>：PLAIN编码是Parquet中最基础的编码方式，它将原始数据直接存储，没有进行任何压缩或变换。该编码方式简单且高效，适用于数据分布均匀的场景，但可能会占用较多存储空间。PLAIN 编码通常用于存储不需要特别优化的字段数据，如简单的整数或字符串。</li>\n<li><strong>DICTIONARY编码</strong>：DICTIONARY编码是一种通过使用字典（映射表）将数据中的重复值替换为字典索引的编码方式。该编码方法适用于有大量重复值的数据类型，比如类别型数据。在Parquet中，数据被分成多个区块，每个区块都会为该区块内的数据生成一个字典。存储时，数据中的重复项会被替换为字典的索引，进而节省存储空间。例如，如果一个字段中有多个相同的值，那么这些值将被映射为字典的索引，存储时只需保存索引而不是重复的值。这种方法能够显著降低存储空间，但需要为每个数据块生成字典，可能会增加读取时的解码开销。</li>\n<li><strong>RLE（Run-Length Encoding）编码</strong>：RLE（Run-Length Encoding）编码是通过记录连续相同值的数量来压缩数据的一种方式。在数据中，若出现连续相同的值，RLE 会记录这些值出现的次数，从而将重复的数据压缩成更小的表示形式。RLE 编码特别适用于数据中存在大量连续相同值的情况。例如，如果一个字段连续出现 100 个相同的数字，那么 RLE 会将其压缩为“值+出现次数”的形式。在 Parquet 中，RLE 编码常用于布尔类型数据或者重复出现的数字类型数据。</li>\n<li><strong>位打包（Bit-Packing）编码</strong>：位打包（Bit-Packing）是一种将多个小数据类型压缩为更小比特数表示的编码方式。该方法通过打包多个值来提高存储效率，通常用于存储较小的数据类型，如整数、布尔值等。Bit-Packing 可以将每个字段中的数据值压缩为最小的比特位数，从而减少存储空间。</li>\n<li><strong>DELTA 编码</strong>：DELTA编码是一种记录数据与其前一个值差异的编码方式。这种方法非常适合存储数值范围比较小且增减变化不大的数据。例如，对于一个增长规律较为平稳的数字序列，DELTA 编码将存储每个数值与前一个数值的差异，而不是存储完整的数值。这样可以显著降低存储空间，特别是对于时间序列数据或连续数据。</li>\n</ol>\n<h3 id=\"2-4-2-编码压缩技术\"><a href=\"#2-4-2-编码压缩技术\" class=\"headerlink\" title=\"2.4.2 编码压缩技术\"></a>2.4.2 编码压缩技术</h3><p>压缩是将数据进一步减少存储空间的技术。Parquet支持多种压缩算法，可以在不牺牲数据质量的情况下，进一步压缩数据以节省存储空间。常见的压缩算法包括Snappy、GZIP、LZO、Brotli等。</p>\n<ol>\n<li>Snappy压缩：Snappy 是 Google 开发的一种压缩算法，具有非常快的压缩和解压缩速度。它的压缩比虽然不如 GZIP，但由于其高效的速度，特别适合大数据处理场景中实时数据处理的需求。Snappy 通常是 Parquet 默认的压缩算法，尤其适用于对速度要求较高的场景。</li>\n<li>GZIP压缩：GZIP是一种较为常见的压缩算法，相较于Snappy，它的压缩比更高，但速度较慢。GZIP压缩适用于对存储空间有较高要求的场景，尤其是当存储成本较高或数据量特别大的时候。GZIP的高压缩比使得它能有效减少存储需求，但解压缩的速度可能成为瓶颈。</li>\n<li>LZO压缩：LZO是一种快速的压缩算法，类似于Snappy，适用于需要快速压缩和解压缩的场景。LZO的压缩比一般不如GZIP，但它的速度非常快，适合于大数据分析中对压缩速度要求较高的应用场景。</li>\n<li>Brotli压缩：Brotli 是由Google开发的一种压缩算法，常用于Web数据传输中的压缩。Brotli的压缩比比GZIP更高，并且其解压速度也较为高效。近年来，Brotli也开始在Parquet中被使用，尤其适用于对存储需求有较高要求的场景。</li>\n<li>Zstandard（ZSTD）压缩：Zstandard（ZSTD）是一种新兴的压缩算法，旨在提供比 GZIP 更高的压缩比和更快的解压速度。ZSTD 兼具了较高的压缩效率和较低的延迟，非常适合需要平衡存储与速度的应用场景。</li>\n</ol>\n<h1 id=\"3-Parquet具体实现\"><a href=\"#3-Parquet具体实现\" class=\"headerlink\" title=\"3. Parquet具体实现\"></a>3. Parquet具体实现</h1><h2 id=\"3-1-Parquet-文件存储格式中的术语\"><a href=\"#3-1-Parquet-文件存储格式中的术语\" class=\"headerlink\" title=\"3.1 Parquet 文件存储格式中的术语\"></a>3.1 Parquet 文件存储格式中的术语</h2><p>在理解 Parquet 文件的存储结构时，熟悉其中关键术语至关重要。以下是 Parquet 中一些核心术语的定义：</p>\n<ul>\n<li><p>**Block (HDFS 块)**：这是 Hadoop 分布式文件系统（HDFS）中数据存储的基本单元，Parquet 文件完全兼容 HDFS 的设计。Block 的大小在 Hadoop 1.x 版本中默认为 64MB，而在 Hadoop 2.x 版本中则增加至 128MB。HDFS 使用 Block 的副本机制来确保数据的冗余和容错能力，从而提高了系统的可靠性和稳定性。</p>\n</li>\n<li><p>**File (文件)**：这是存储在 HDFS 上的一个逻辑实体，包含文件的元数据信息，但其实际数据内容由多个 HDFS Block 保存。</p>\n</li>\n<li><p>**Row Group (行组)**：Parquet 将数据按行划分为多个逻辑上的水平分区。每个 Row Group 包含该组中所有列的列块（Column Chunk），是并行化和 IO 操作的基本单元。这样设计使得每个行组都可以独立解码，便于分布式处理。</p>\n</li>\n<li><p>**Column Chunk (列块)**：指单列数据在一个行组中的物理存储。列块在行组中是逻辑连续的，这种设计允许对列进行有效的压缩和编码，从而提高了存储的利用率。</p>\n</li>\n<li><p>**Page (页面)**：列块被进一步划分为多个 Page，这是 Parquet 文件压缩和编码的最小基本单元。每个列块中可能包含多个类型的 Page，例如数据页面、字典页面等。</p>\n</li>\n</ul>\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/format.png\" style=\"width:66%;\"/>\n</div>\n\n<h2 id=\"3-2-并行化执行的基本单元\"><a href=\"#3-2-并行化执行的基本单元\" class=\"headerlink\" title=\"3.2 并行化执行的基本单元\"></a>3.2 并行化执行的基本单元</h2><p>在 Parquet 文件中，不同层级的数据单元在并行化处理和 IO 操作中发挥不同的作用：</p>\n<ul>\n<li><p><strong>MapReduce 任务划分</strong>：在使用 Hadoop 的 MapReduce 框架处理数据时，通常以 File 或 Row Group 为基本单位来分配任务，即每个任务处理一个完整的文件或者一个行组，从而实现并行化。</p>\n</li>\n<li><p><strong>IO 操作</strong>：Parquet 文件的 IO 操作以 Column Chunk 为基本单位进行。这种设计方式使得可以只读取所需列的数据，减少不必要的磁盘 IO，从而提高读取效率。</p>\n</li>\n<li><p><strong>编码和压缩</strong>：在 Parquet 中，编码和压缩通常以 Page 为单位进行。每个页面可以使用不同的编码方法来提高压缩率，例如使用 RLE（Run Length Encoding）对重复值进行压缩，从而降低存储空间。</p>\n</li>\n</ul>\n<h2 id=\"3-3-Parquet-文件格式\"><a href=\"#3-3-Parquet-文件格式\" class=\"headerlink\" title=\"3.3 Parquet 文件格式\"></a>3.3 Parquet 文件格式</h2><p>Parquet 文件格式具有自解析的特性，文件使用 Thrift 格式定义 schema 以及其他元数据信息。这些元数据信息存储在文件末尾，方便读取时直接访问。</p>\n<p>典型的 Parquet 文件结构如下：</p>\n<ul>\n<li>整个文件被划分为多个行组，每个行组包含所有列的数据块和元数据信息。</li>\n<li>文件的元数据存储在数据部分的最后，包含了所有列块元数据的起始位置。</li>\n</ul>\n<p>这种将元数据存储在文件末尾的设计，使得在写入数据时可以顺序高效地写入文件，同时在读取文件时可以快速获取元数据并定位到相关数据块。</p>\n<div style=\"text-align: center;\">\n  <img src=\"/blog/images/metadata.png\" style=\"width:66%;\"/>\n</div>\n\n<h2 id=\"3-4-元数据信息\"><a href=\"#3-4-元数据信息\" class=\"headerlink\" title=\"3.4 元数据信息\"></a>3.4 元数据信息</h2><p>Parquet 文件包含三种不同类型的元数据，每种元数据在不同层级描述文件的内容和结构：</p>\n<ul>\n<li><strong>文件元数据</strong>：描述整个文件的结构和内容，例如行组和列块的位置信息等，是文件级别的数据概览。</li>\n<li><strong>列（块）元数据</strong>：描述单个列块的详细信息，包括该列块的属性、位置和大小。这些元数据使得读取特定列块变得更加高效。</li>\n<li><strong>页面头部元数据</strong>：描述每个页面的具体属性，包括编码方式、压缩方法、页面位置等。这些元数据对于解码和读取页面中的数据至关重要。</li>\n</ul>\n<h2 id=\"3-5-并行读取与列存储的优化\"><a href=\"#3-5-并行读取与列存储的优化\" class=\"headerlink\" title=\"3.5 并行读取与列存储的优化\"></a>3.5 并行读取与列存储的优化</h2><p>Parquet 的设计充分考虑了并行处理和列存储的优势。由于数据是按列存储的，因此可以非常高效地进行列的读取操作。尤其是对于只需要部分列的查询，Parquet 能够显著减少 IO 开销，提升性能。每个行组中的列块在物理上保持连续存储，这样即使是大规模并行读取也可以最大程度减少磁盘寻道时间。</p>\n<h2 id=\"3-6-编码（Encoding）\"><a href=\"#3-6-编码（Encoding）\" class=\"headerlink\" title=\"3.6 编码（Encoding）\"></a>3.6 编码（Encoding）</h2><p>Parquet 支持多种编码方式，以优化数据的压缩和读取效率。细节可以参考官方文档：<a href=\"https://github.com/apache/parquet-format/blob/master/Encodings.md\">Parquet Encodings</a>。通过采用不同的编码方法，Parquet 能够大幅度减少重复值存储，从而节省磁盘空间。</p>\n<h2 id=\"3-7-Column-Chunks-存储与读取\"><a href=\"#3-7-Column-Chunks-存储与读取\" class=\"headerlink\" title=\"3.7 Column Chunks 存储与读取\"></a>3.7 Column Chunks 存储与读取</h2><p>每个 Column Chunk 是由多个 Page 组成的。在读取数据时，Parquet Reader 可以利用页面头部元数据中存储的信息，直接跳过不感兴趣的页面。例如，字典页面与数据页面存储的内容类型不同，Reader 可以根据需求决定是否需要加载某些页面，从而优化查询性能。</p>\n<h2 id=\"3-8-错误处理机制\"><a href=\"#3-8-错误处理机制\" class=\"headerlink\" title=\"3.8 错误处理机制\"></a>3.8 错误处理机制</h2><p>Parquet 文件设计了一系列机制来应对数据损坏的情况，以保证数据的可用性和可靠性：</p>\n<ul>\n<li><strong>文件元数据损坏</strong>：如果整个文件的元数据损坏，通常情况下整个文件会无法读取。</li>\n<li><strong>列元数据损坏</strong>：如果某个列的元数据损坏，只会影响该列块的读取，其他行组中相同列的块仍可正常使用，这种设计能够减少局部损坏对整体数据的影响。</li>\n<li><strong>页面头部损坏</strong>：当页面头部损坏时，该列块中的所有后续页面将无法读取。</li>\n<li><strong>页面数据损坏</strong>：如果某个页面的数据损坏，通常只会导致该页面的数据不可用，其它页面的数据仍然可用。</li>\n</ul>\n<p>较小的行组设置可以更好地抵抗数据损坏，因为损坏只会影响较小的数据范围，而不会影响整个文件。</p>\n<h2 id=\"3-9-推荐的配置参数\"><a href=\"#3-9-推荐的配置参数\" class=\"headerlink\" title=\"3.9 推荐的配置参数\"></a>3.9 推荐的配置参数</h2><p>为了实现最佳的性能和可靠性，Parquet 提供了一些推荐配置：</p>\n<ul>\n<li><p><strong>行组大小（Row group size）</strong>：较大的行组可以使列块变得更大，进而提升顺序 IO 的性能。虽然较大的行组需要更多的内存缓存，但它能够有效减少 IO 操作次数，从而提升性能。Parquet 推荐的行组大小为 512MB 至 1GB。此外，行组最好与 HDFS 的 Block 大小对齐，以减少跨 Block 的 IO 操作。理想的配置是行组大小和 HDFS Block 大小均为 1GB，并保证每个 HDFS 文件对应一个 HDFS Block。</p>\n</li>\n<li><p><strong>数据页大小（Data page size）</strong>：数据页是不可分割的存储单元。较小的数据页允许更精细的随机访问（如单行查找），但会增加 page header 的数量，从而带来空间开销。较大的数据页可以降低页面头部的开销，提升数据解析的效率。Parquet 推荐的数据页大小为 8KB，以在性能与空间利用率之间取得平衡。</p>\n</li>\n</ul>\n<p>总结来看，Parquet 文件格式通过行组、列块、页面三级结构，结合丰富的元数据信息和多种编码方式，达到了高效的数据存储和读取性能。其列式存储特性使得数据的压缩率大幅提高，并能高效支持大规模的并行查询。对于需要处理海量数据的场景，Parquet 是一种高效而可靠的数据存储格式。</p>\n<h1 id=\"4-Python使用Parquet\"><a href=\"#4-Python使用Parquet\" class=\"headerlink\" title=\"4. Python使用Parquet\"></a>4. Python使用Parquet</h1><h2 id=\"4-1-安装依赖并导入\"><a href=\"#4-1-安装依赖并导入\" class=\"headerlink\" title=\"4.1 安装依赖并导入\"></a>4.1 安装依赖并导入</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pyarrow pandas</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pyarrow <span class=\"keyword\">as</span> pa</span><br><span class=\"line\"><span class=\"keyword\">import</span> pyarrow.parquet <span class=\"keyword\">as</span> pq</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2-定义schema\"><a href=\"#4-2-定义schema\" class=\"headerlink\" title=\"4.2 定义schema\"></a>4.2 定义schema</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schema = pa.schema([</span><br><span class=\"line\">    (<span class=\"string\">&quot;id&quot;</span>, pa.int32()),</span><br><span class=\"line\">    (<span class=\"string\">&quot;speeds&quot;</span>, pa.list_(pa.float64())),</span><br><span class=\"line\">    (<span class=\"string\">&quot;trajectory&quot;</span>, pa.map_(</span><br><span class=\"line\">        pa.timestamp(<span class=\"string\">&#x27;ms&#x27;</span>),  </span><br><span class=\"line\">        pa.struct([   </span><br><span class=\"line\">            (<span class=\"string\">&quot;latitude&quot;</span>, pa.float64()),</span><br><span class=\"line\">            (<span class=\"string\">&quot;longitude&quot;</span>, pa.float64())</span><br><span class=\"line\">        ])</span><br><span class=\"line\">    ))</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-3-导入数据\"><a href=\"#4-3-导入数据\" class=\"headerlink\" title=\"4.3 导入数据\"></a>4.3 导入数据</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;id&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;speeds&quot;</span>: [<span class=\"number\">12.5</span>, <span class=\"number\">13.2</span>, <span class=\"number\">14.1</span>],</span><br><span class=\"line\">        <span class=\"string\">&quot;trajectory&quot;</span>: &#123;</span><br><span class=\"line\">            datetime(<span class=\"number\">2024</span>, <span class=\"number\">11</span>, <span class=\"number\">21</span>, <span class=\"number\">10</span>, <span class=\"number\">0</span>): &#123;<span class=\"string\">&quot;latitude&quot;</span>: <span class=\"number\">40.7128</span>, <span class=\"string\">&quot;longitude&quot;</span>: -<span class=\"number\">74.0060</span>&#125;,</span><br><span class=\"line\">            datetime(<span class=\"number\">2024</span>, <span class=\"number\">11</span>, <span class=\"number\">21</span>, <span class=\"number\">10</span>, <span class=\"number\">5</span>): <span class=\"literal\">None</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;id&quot;</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;speeds&quot;</span>: [<span class=\"number\">20.1</span>, <span class=\"number\">21.3</span>],</span><br><span class=\"line\">        <span class=\"string\">&quot;trajectory&quot;</span>: &#123;</span><br><span class=\"line\">            datetime(<span class=\"number\">2024</span>, <span class=\"number\">11</span>, <span class=\"number\">21</span>, <span class=\"number\">11</span>, <span class=\"number\">0</span>): &#123;<span class=\"string\">&quot;latitude&quot;</span>: <span class=\"number\">34.0522</span>, <span class=\"string\">&quot;longitude&quot;</span>: -<span class=\"number\">118.2437</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-4-生成parquet文件\"><a href=\"#4-4-生成parquet文件\" class=\"headerlink\" title=\"4.4 生成parquet文件\"></a>4.4 生成parquet文件</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compression_method = <span class=\"string\">&#x27;gzip&#x27;</span> <span class=\"comment\">#(snappy、lzo、brotli ...)</span></span><br><span class=\"line\">table = pa.Table.from_pandas(df, schema=schema)</span><br><span class=\"line\">pq.write_table(table, <span class=\"string\">&quot;example.parquet&quot;</span>, compression_method)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-4读取parquet文件并且查看格式信息\"><a href=\"#4-4读取parquet文件并且查看格式信息\" class=\"headerlink\" title=\"4.4读取parquet文件并且查看格式信息\"></a>4.4读取parquet文件并且查看格式信息</h2><h3 id=\"4-4-1-读取parquet文件\"><a href=\"#4-4-1-读取parquet文件\" class=\"headerlink\" title=\"4.4.1 读取parquet文件\"></a>4.4.1 读取parquet文件</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read_table = pq.read_table(<span class=\"string\">&quot;exmaple.parquet&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(read_table.to_pandas())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  id        speeds                                         trajectory</span><br><span class=\"line\">0   1  [45.5, 60.2]  [&#123;&#x27;key&#x27;: 2024-11-21 10:30:00, &#x27;value&#x27;: &#123;&#x27;latit...</span><br><span class=\"line\">1   2  [35.2, 50.0]  [&#123;&#x27;key&#x27;: 2024-11-21 11:00:00, &#x27;value&#x27;: &#123;&#x27;latit...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-2-查看schame-元信息\"><a href=\"#4-4-2-查看schame-元信息\" class=\"headerlink\" title=\"4.4.2 查看schame&amp;元信息\"></a>4.4.2 查看schame&amp;元信息</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parquet_file = pq.ParquetFile(<span class=\"string\">&quot;example&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;元信息：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(parquet_file.metadata)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nSchema：&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(parquet_file.schema)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 元信息：</span><br><span class=\"line\">&lt;pyarrow._parquet.FileMetaData object at 0x000002019E93A980&gt;</span><br><span class=\"line\">  created_by: parquet-cpp-arrow version 18.0.0-SNAPSHOT</span><br><span class=\"line\">  num_columns: 5</span><br><span class=\"line\">  num_rows: 2</span><br><span class=\"line\">  num_row_groups: 1</span><br><span class=\"line\">  format_version: 2.6</span><br><span class=\"line\">  serialized_size: 3014</span><br><span class=\"line\"></span><br><span class=\"line\">Schema：</span><br><span class=\"line\">&lt;pyarrow._parquet.ParquetSchema object at 0x000002019E9F0A40&gt;</span><br><span class=\"line\">required group field_id=-1 schema &#123;</span><br><span class=\"line\">  optional int32 field_id=-1 id;</span><br><span class=\"line\">  optional group field_id=-1 speeds (List) &#123;</span><br><span class=\"line\">    repeated group field_id=-1 list &#123;</span><br><span class=\"line\">      optional double field_id=-1 element;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  optional group field_id=-1 trajectory (Map) &#123;</span><br><span class=\"line\">    repeated group field_id=-1 key_value &#123;</span><br><span class=\"line\">      required int64 field_id=-1 key (Timestamp(isAdjustedToUTC=false, timeUnit=milliseconds, is_from_converted_type=false, force_set_converted_type=false));</span><br><span class=\"line\">      optional group field_id=-1 value &#123;</span><br><span class=\"line\">        optional double field_id=-1 latitude;</span><br><span class=\"line\">        optional double field_id=-1 longitude;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-3-查看列信息\"><a href=\"#4-4-3-查看列信息\" class=\"headerlink\" title=\"4.4.3 查看列信息\"></a>4.4.3 查看列信息</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row_group = parquet_file.metadata.row_group(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> col_idx <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(parquet_file.metadata.num_columns):</span><br><span class=\"line\">    column = row_group.column(col_idx)</span><br><span class=\"line\">    column_name = parquet_file.schema.column(col_idx).name</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;列 <span class=\"subst\">&#123;col_idx&#125;</span> (<span class=\"subst\">&#123;column_name&#125;</span>) 信息：&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  总值数量：<span class=\"subst\">&#123;column.num_values&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  压缩大小：<span class=\"subst\">&#123;column.total_compressed_size&#125;</span> 字节&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  未压缩大小：<span class=\"subst\">&#123;column.total_uncompressed_size&#125;</span> 字节&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  最大值：<span class=\"subst\">&#123;column.statistics.<span class=\"built_in\">max</span> <span class=\"keyword\">if</span> column.statistics <span class=\"keyword\">else</span> <span class=\"string\">&#x27;无统计信息&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  最小值：<span class=\"subst\">&#123;column.statistics.<span class=\"built_in\">min</span> <span class=\"keyword\">if</span> column.statistics <span class=\"keyword\">else</span> <span class=\"string\">&#x27;无统计信息&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  空值数量：<span class=\"subst\">&#123;column.statistics.null_count <span class=\"keyword\">if</span> column.statistics <span class=\"keyword\">else</span> <span class=\"string\">&#x27;无统计信息&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  列 0 (id) 信息：</span><br><span class=\"line\">  总值数量：2</span><br><span class=\"line\">  压缩大小：80 字节</span><br><span class=\"line\">  未压缩大小：76 字节</span><br><span class=\"line\">  最大值：2</span><br><span class=\"line\">  最小值：1</span><br><span class=\"line\">  空值数量：0</span><br><span class=\"line\">---</span><br><span class=\"line\">列 1 (element) 信息：</span><br><span class=\"line\">  总值数量：5</span><br><span class=\"line\">  压缩大小：130 字节</span><br><span class=\"line\">  未压缩大小：132 字节</span><br><span class=\"line\">  最大值：21.3</span><br><span class=\"line\">  最小值：12.5</span><br><span class=\"line\">  空值数量：0</span><br><span class=\"line\">---</span><br><span class=\"line\">列 2 (key) 信息：</span><br><span class=\"line\">  总值数量：3</span><br><span class=\"line\">  压缩大小：119 字节</span><br><span class=\"line\">  未压缩大小：115 字节</span><br><span class=\"line\">  最大值：2024-11-21 11:00:00</span><br><span class=\"line\">  最小值：2024-11-21 10:00:00</span><br><span class=\"line\">  空值数量：0</span><br><span class=\"line\">---</span><br><span class=\"line\">列 3 (latitude) 信息：</span><br><span class=\"line\">  总值数量：3</span><br><span class=\"line\">  压缩大小：119 字节</span><br><span class=\"line\">  未压缩大小：115 字节</span><br><span class=\"line\">  最大值：40.7138</span><br><span class=\"line\">  最小值：34.0522</span><br><span class=\"line\">  空值数量：0</span><br><span class=\"line\">---</span><br><span class=\"line\">列 4 (longitude) 信息：</span><br><span class=\"line\">  总值数量：3</span><br><span class=\"line\">  压缩大小：119 字节</span><br><span class=\"line\">  未压缩大小：115 字节</span><br><span class=\"line\">  最大值：-74.006</span><br><span class=\"line\">  最小值：-118.2437</span><br><span class=\"line\">  空值数量：0</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-4-查看列编码方式\"><a href=\"#4-4-4-查看列编码方式\" class=\"headerlink\" title=\"4.4.4 查看列编码方式\"></a>4.4.4 查看列编码方式</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> col_idx <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(parquet_file.metadata.num_columns):</span><br><span class=\"line\">    column_encoding = parquet_file.metadata.row_group(<span class=\"number\">0</span>).column(col_idx).encodings</span><br><span class=\"line\">    column_name = parquet_file.schema.column(col_idx).name</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;列 <span class=\"subst\">&#123;col_idx&#125;</span> (<span class=\"subst\">&#123;column_name&#125;</span>) 编码方式：&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  Encodings: <span class=\"subst\">&#123;column_encoding&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---&quot;</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">列 0 (id) 编码方式：</span><br><span class=\"line\">  Encodings: (&#x27;PLAIN&#x27;, &#x27;RLE&#x27;, &#x27;RLE_DICTIONARY&#x27;)</span><br><span class=\"line\">---</span><br><span class=\"line\">列 1 (element) 编码方式：</span><br><span class=\"line\">  Encodings: (&#x27;PLAIN&#x27;, &#x27;RLE&#x27;, &#x27;RLE_DICTIONARY&#x27;)</span><br><span class=\"line\">---</span><br><span class=\"line\">列 2 (key) 编码方式：</span><br><span class=\"line\">  Encodings: (&#x27;PLAIN&#x27;, &#x27;RLE&#x27;, &#x27;RLE_DICTIONARY&#x27;)</span><br><span class=\"line\">---</span><br><span class=\"line\">列 3 (latitude) 编码方式：</span><br><span class=\"line\">  Encodings: (&#x27;PLAIN&#x27;, &#x27;RLE&#x27;, &#x27;RLE_DICTIONARY&#x27;)</span><br><span class=\"line\">---</span><br><span class=\"line\">列 4 (longitude) 编码方式：</span><br><span class=\"line\">  Encodings: (&#x27;PLAIN&#x27;, &#x27;RLE&#x27;, &#x27;RLE_DICTIONARY&#x27;)</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h1><p>本文详细介绍了 Apache Parquet 格式的原理与实践，重点讲解了其列式存储结构、嵌套数据支持、编码与压缩技术、以及如何在 Python 中使用 Parquet 文件。Parquet 的设计充分利用了列式存储的优势，特别是在大数据分析场景中，它能够显著提高查询效率并有效节省存储空间。</p>\n<ol>\n<li><p><strong>列式存储优势</strong>：Parquet 的列式存储方式使得在进行数据分析时，可以只读取所需的列，减少了不必要的磁盘 I&#x2F;O 操作。此外，列式存储能高效地压缩数据，特别是对于重复性高的数据，能够显著减少存储空间的占用。</p>\n</li>\n<li><p><strong>复杂嵌套结构支持</strong>：通过使用 Repetition Levels 和 Definition Levels，Parquet 能够高效处理复杂的嵌套数据结构，例如 List 和 Map。这种设计让 Parquet 格式在处理包含多个嵌套字段的复杂数据时，保持高效且灵活。</p>\n</li>\n<li><p><strong>编码与压缩技术</strong>：Parquet 支持多种编码方式（如 PLAIN、DICTIONARY、RLE 编码等）和压缩算法（如 Snappy、GZIP、LZO 等）。这些技术帮助优化存储空间并提升数据读取性能。在不同的场景下，用户可以选择适合的编码和压缩方法，以平衡存储与速度的需求。</p>\n</li>\n<li><p><strong>Python 使用 Parquet</strong>：通过 <code>pyarrow</code> 库，Python 用户能够轻松地创建、读取和操作 Parquet 文件。示例代码展示了如何定义 Parquet 文件的 schema、将数据导入并生成 Parquet 文件，以及如何读取 Parquet 文件并查看其元数据和编码信息。</p>\n</li>\n<li><p><strong>性能优化</strong>：Parquet 的设计考虑了并行处理，支持高效的列读取操作，这对于大规模数据处理非常重要。它通过将数据划分为行组（Row Groups）、列块（Column Chunks）和页面（Pages），使得分布式计算框架如 Hadoop 和 Spark 能够高效地处理数据。</p>\n</li>\n</ol>\n<p>总的来说，Parquet 是一种功能强大的数据存储格式，它结合了列式存储的优势与高效的压缩、编码技术，特别适合用于大数据分析和大规模分布式计算环境中。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm3rcvwhi0004usb0677uhn26","category_id":"cm3rcvwhl0006usb0ev9i8v3g","_id":"cm3rcvwhq000ausb033dw0klz"},{"post_id":"cm3rcvwhk0005usb000qkdl25","category_id":"cm3rcvwhp0008usb03or5duke","_id":"cm3rcvwhq000eusb0chjv6h83"}],"PostTag":[{"post_id":"cm3rcvwhi0004usb0677uhn26","tag_id":"cm3rcvwhp0007usb0bllba1v1","_id":"cm3rcvwhq000cusb09h0r5sqr"},{"post_id":"cm3rcvwhi0004usb0677uhn26","tag_id":"cm3rcvwhp0009usb03zyq60ir","_id":"cm3rcvwhq000dusb04uu5fyvq"},{"post_id":"cm3rcvwhk0005usb000qkdl25","tag_id":"cm3rcvwhq000busb01r6afail","_id":"cm3rcvwhq000gusb0aq2j984i"},{"post_id":"cm3rcvwhk0005usb000qkdl25","tag_id":"cm3rcvwhq000fusb06jnf7d6a","_id":"cm3rcvwhq000husb0aljl9t86"}],"Tag":[{"name":"路网","_id":"cm3rcvwhp0007usb0bllba1v1"},{"name":"Python","_id":"cm3rcvwhp0009usb03zyq60ir"},{"name":"parquet","_id":"cm3rcvwhq000busb01r6afail"},{"name":"文件存储","_id":"cm3rcvwhq000fusb06jnf7d6a"}]}}